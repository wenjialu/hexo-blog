<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>超级好用的 git 可视化软件</title>
    <url>/hexo-blog/2021/01/14/%20git%20%E5%8F%AF%E8%A7%86%E5%8C%96%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<p>![image-20210114214813891](/Users/lujiawen/Library/Application Support/typora-user-images/image-20210114214813891.png)</p>
<p>![image-20210114214611594](/Users/lujiawen/Library/Application Support/typora-user-images/image-20210114214611594.png)</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>how to create a new post in hexo</title>
    <url>/hexo-blog/2020/10/12/%20how%20to%20create%20a%20new%20post%20in%20hexo/</url>
    <content><![CDATA[<p>把以下路径放到系统变量中，就可以直接用以下命令创建新的博客内容啦。<br>路径以这个为结尾的 ….\hexo\node_modules.bin<br>[好像不行]</p>
<p>hexo n “blog名”<br><a href="https://hexo.io/docs/writing">https://hexo.io/docs/writing</a><br>打开：<br>open ./blog名</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>1～2～3 三步创建一个 Django 项目 【SOP】</title>
    <url>/hexo-blog/2020/01/03/1%EF%BD%9E2%EF%BD%9E3%20%E4%B8%89%E6%AD%A5%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%20Django%20%E9%A1%B9%E7%9B%AE%20%E3%80%90SOP%E3%80%91/</url>
    <content><![CDATA[<p>进入到运行 Django 的虚拟环境。workon Django_web（虚拟环境篇）</p>
<p>找一个自己喜欢的位置，比如桌面。</p>
<h2 id="1-建-Django-项目"><a href="#1-建-Django-项目" class="headerlink" title="1 建 Django 项目"></a>1 建 Django 项目</h2><p>在系统终端 或者 VScode 终端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">django-admin startproject 项目名<br></code></pre></td></tr></table></figure>

<h2 id="2-建子应用"><a href="#2-建子应用" class="headerlink" title="2 建子应用"></a>2 建子应用</h2><p>2.1 创造</p>
<p>进到这个目录中去，<code>cd 项目名。</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">django-admin startapp 应用名<br></code></pre></td></tr></table></figure>

<p>2.2 注册</p>
<p>进入到项目同名目录，里面有个 settings.py 文件。</p>
<p>找到INSTALLED_APPS，把应用名添加到这里面。</p>
<h2 id="3-启动项目"><a href="#3-启动项目" class="headerlink" title="3 启动项目"></a>3 启动项目</h2><p><code>python manage.py runserver</code></p>
<p>完成～～<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1got35wx1jbj30u00j5405.jpg"></p>
<p>导入介绍语（why need 后台管理）～～～～</p>
<p><strong>后台管理：</strong></p>
<p>首先创建一个管理员账号：</p>
<p>python manage.py createsuperuser</p>
<p>终端面板会提示你设置用户名和密码。</p>
<p>然后打开admin.py，注册一下你的模型类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">from yourapp.models import yourModel1, yourModel2<br><br>admin.site.register(yourModel)<br>admin.site.register(yourModel2)<br></code></pre></td></tr></table></figure>



<p>通过 localhost:8000/admin 访问后台面板，就能看到自己注册的模型类的具体信息啦。</p>
]]></content>
  </entry>
  <entry>
    <title>50 projects - to do list</title>
    <url>/hexo-blog/2021/02/03/50%20proojects%20-%20to%20do%20list/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/wenjialu/todolist-app/main/todo-list-demo1.gif" alt="效果展示"></p>
<h2 id="to-do-list"><a href="#to-do-list" class="headerlink" title="to do list"></a>to do list</h2><h3 id="静态样式及代码："><a href="#静态样式及代码：" class="headerlink" title="静态样式及代码："></a>静态样式及代码：</h3><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmzxxii2xrj30k00ck0v6.jpg" />





<h3 id="动态功能："><a href="#动态功能：" class="headerlink" title="动态功能："></a>动态功能：</h3><p><strong>知识点预览：</strong></p>
<p> <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/classList">classList</a> 的方法 add， toggle 等</p>
<p>右键 – 检查 – application – storage – local storage</p>
<p><a href="https://developers.google.com/web/tools/chrome-devtools/storage/localstorage?utm_source=devtools">Localstorage</a> 的方法setItem, getItem.</p>
<p>Local storage.setItem(key, value)</p>
<p>js ：</p>
<h4 id="功能1-ADD"><a href="#功能1-ADD" class="headerlink" title="功能1: ADD"></a><strong>功能1: ADD</strong></h4><p>填写todo，回车后会添加到我的待办列表里面。</p>
<p><strong>实现思路：</strong>代办列表是个取名为 todosUL 的列表，</p>
<p>只有document 的 element 才能被append进去, 而 text 不能被append到  todosUL 这个列表中。</p>
<p>所以要创造一个 element，并赋值为 input.value。</p>
<p>tips: 1.要先用一个变量 todoText 存储  input.value, 对其做个简单的判断防止其为空。</p>
<ol start="2">
<li><p>todo.text todotext </p>
<p> todotext 不一定是当下输入的，也可能是之前输入的todo.text.</p>
</li>
</ol>
<p> 1 what is  todo.completed?</p>
<p><del>2 why <strong>if(todo &amp;&amp; todo.completed)</strong>{  。。 classList.add(。。）} 才能生效啊 。A：不，不是这样的</del></p>
<p><strong>答疑：</strong>关于 classList.add(“completed”)。</p>
<p>在这个功能中不是必要的。</p>
<p>这只是打个标签，</p>
<p>后续实现保存列表内容的功能时，会依据这个标签做出相应的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 伪代码<br><br>listen submit? <br><br>adddTodo(?)&#123;<br>  #输入的文字<br>  let todoText = input.value<br><br>   # 1.what is ? ?  2. what is classList.add? 3 why set innerText<br>   if(todoText)&#123;<br>          const todoEL = document.createElement(&quot;li&quot;)<br>          <br>          //if( ？ &amp;&amp; ？.completed)&#123;<br>          //    todoEL.classList.add(&quot;completed&quot;)<br>          //&#125;<br>          <br>           todoEL.innerText = todoText<br><br>            todosUL.appendChild(todoEL)<br>            console.log(todosUL)<br>            <br>            todo.value = &quot;&quot;<br><br>      &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="功能2-MARK-COMPLETE-amp-REMOVE"><a href="#功能2-MARK-COMPLETE-amp-REMOVE" class="headerlink" title="功能2: MARK COMPLETE &amp; REMOVE"></a><strong>功能2: MARK COMPLETE &amp; REMOVE</strong></h4><p>MARK COMPLET: 鼠标左击，待办就用（下划线划掉的方式）标记为完成</p>
<p>REMOVE: 鼠标右击，待办从列表中消失</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">todoEL.addEventListener(&quot;click&quot;,()=&gt;todoEL.classList.toggle(&quot;completed&quot;))<br><br>todoEL.addEventListener(&quot;contextmenu&quot;,(e)=&gt;&#123;<br>	e.preventDefault()<br>	todoEL.remove()<br>&#125;)<br><br></code></pre></td></tr></table></figure>





<h4 id="功能3：-刷新待办不会消失"><a href="#功能3：-刷新待办不会消失" class="headerlink" title="功能3： 刷新待办不会消失"></a><strong>功能3： 刷新待办不会消失</strong></h4><p>思路： 对于上述3种操作：增删改，每次操作都记录在 localstorage本地存储 中。</p>
<p>写一个 updateLS() 函数实现保存功能，并在每个方法后触发。</p>
<p>Q: 我已经写入到local storage了 ， 为啥还是一刷新就没了</p>
<p>猜想；setitem 写对，getitem写错？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">// change string to array<br>const todos = JSON.parse(localStorage.getItem(&quot;todos&quot;))<br><br>if (todos)&#123;<br>    todos.forEach(todo =&gt; addToDo(todo))<br>&#125;<br><br><br>方法1/2/3&#123;<br> ...<br> updateLS()<br>&#125;<br><br><br><br>function updateLS()&#123;<br>        todosEL = document.querySelectorAll(&quot;li&quot;)<br>        <br>        todosEL.forEach(todoEL =&gt;&#123;<br>            todos.push(&#123;<br>                text: todoEL.innerText,<br>                completed: todoEL.classList.contains(&quot;completed&quot;)<br>            &#125;)<br>        &#125;)<br>         // todos is an object, change it to string<br>        localStorage.setItem(&quot;todos&quot;,JSON.stringify(todos))<br>    &#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="知识点总结："><a href="#知识点总结：" class="headerlink" title="知识点总结："></a>知识点总结：</h4><p>Localstorage 的方法setItem, getItem.</p>
<p>每次增删改触发存储方法，把数据放到Localstorage；然后再从Localstorage里取出来的数据基础上，实现增删改</p>
<p><strong>Resources :</strong></p>
<p>Cdnjs -&gt;font-awesome</p>
<p>Fonts.google.com</p>
]]></content>
      <tags>
        <tag>50 projects</tag>
      </tags>
  </entry>
  <entry>
    <title>50 projects - draw app</title>
    <url>/hexo-blog/2021/01/12/50-projects-draw-app/</url>
    <content><![CDATA[<p>可以把这个js 加到我的个人网站里。</p>
]]></content>
  </entry>
  <entry>
    <title>50 projects - netflix navigation</title>
    <url>/hexo-blog/2021/01/12/50-projects-netflix-navigation/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>About me</title>
    <url>/hexo-blog/2020/09/20/About-me/</url>
    <content><![CDATA[<p>In 1996, a little girl was born in Shanghai, China. In 2019 at her age of 23, she pursued her dream of studying NeuroPsychology and Computer Science in the University of Edinburgh. What makes her her and what would happened to her during her journey of foreign    land?<br>Let’s come and have a look! </p>
]]></content>
  </entry>
  <entry>
    <title>git 疑难杂症大全 （更新中）</title>
    <url>/hexo-blog/2020/12/09/Git%20%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Git-令人吐血使人窒息，看我如何与它斗智斗勇！"><a href="#Git-令人吐血使人窒息，看我如何与它斗智斗勇！" class="headerlink" title="Git 令人吐血使人窒息，看我如何与它斗智斗勇！"></a>Git 令人吐血使人窒息，看我如何与它斗智斗勇！</h1><p>最新更新：</p>
<p>花了 68 元 买了 daisy</p>
<p>把磁盘空间的问题解决之后。</p>
<p>终端的pull 和 push 操作没有啥问题了， 操作相当的丝滑。</p>
<p>But 我终于发现了真正的问题所在，</p>
<p>在于 github page 构建不成功诶。</p>
<p>疑难杂症检查：</p>
<p><a href="https://docs.github.com/cn/free-pro-team@latest/github/working-with-github-pages/troubleshooting-jekyll-build-errors-for-github-pages-sites">https://docs.github.com/cn/free-pro-team@latest/github/working-with-github-pages/troubleshooting-jekyll-build-errors-for-github-pages-sites</a></p>
<ul>
<li>可能是我的仓库太大了。没有啊，才300m，没有超过1g。</li>
</ul>
<h2 id="问题初显"><a href="#问题初显" class="headerlink" title="问题初显"></a>问题初显</h2><p>事情的起因是这样的，我不是自己建了好几个网站嘛。</p>
<p>有的是为了好玩，比如前文提到的hexo； 还有的我拿来当电子简历了（嘻嘻，简历网站就没有公开了啦）。</p>
<p>我在面试某东的时候，面试官竟然对我的简历版的网站很有兴趣，并且对着我网站上列举出的技术栈进行了狂轰滥炸式的考察。</p>
<p>面试最后还不忘夸了夸我的网站设计。 呜！受宠若惊～</p>
<p>但其实我还有点不满意的点，于是在面试结束后就马不停蹄的去修改了。</p>
<p>当我提交完，兴奋的想去看网站效果的时候。 </p>
<p>咦，怎么毫无变化？ </p>
<p>我反复刷新刷新页面，最后又回到github上看。</p>
<p>嘶 !!! 竟然。。。</p>
<h2 id="github上提交的修改commit都没成功！"><a href="#github上提交的修改commit都没成功！" class="headerlink" title="github上提交的修改commit都没成功！"></a>github上提交的修改commit都没成功！</h2><p>![image-20201113031438774](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201113031438774.png)</p>
<p>纳尼，咋都没提交上呢？？？  </p>
<p>原来前一天终端的git commit 也没有成功，但是终端这个铁憨憨好像没有发现，还提示 Everything up-to-date (主人，一切都更新好了哦！), 仿佛一切安好的样子。</p>
<p>![image-20201113000622941](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201113000622941.png)</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>工欲善其事， 必先利其器。</p>
<p>但是好像我的解决问题工具都有些问题，哭哭。</p>
<h4 id="工具-1-github-desktop-image-20201113032007246-Users-lujiawen-Library-Application-Support-typora-user-images-image-20201113032007246-png"><a href="#工具-1-github-desktop-image-20201113032007246-Users-lujiawen-Library-Application-Support-typora-user-images-image-20201113032007246-png" class="headerlink" title="工具 1 github desktop ![image-20201113032007246](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201113032007246.png)"></a>工具 1 github desktop ![image-20201113032007246](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201113032007246.png)</h4><p>曾经是个非常好用的一个应用端可视化管理git的平台。</p>
<p>直到。。。我建了那个hexo_blog加了个ssh密钥之后。</p>
<p><strong>总是有问题，不是ssh 连接失败，就是commit提交error -1.或者狂按fetch也没有反应。</strong></p>
<p>哎，先不用它了。</p>
<h4 id="工具-2-终端"><a href="#工具-2-终端" class="headerlink" title="工具 2 终端"></a>工具 2 终端</h4><p> 终端是个天真的铁憨憨，始终觉得自己同步完了，git树很干净。</p>
<p>。。。 </p>
<p>这究竟是为啥？</p>
<p>嗷呜，先不去打扰它对这个世界的美好幻想了。</p>
<p>![image-20201113023439128](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201113023439128.png)</p>
<h4 id="工具-3-我自己的手👋–手动同步"><a href="#工具-3-我自己的手👋–手动同步" class="headerlink" title="工具 3 我自己的手👋–手动同步"></a>工具 3 我自己的手👋–手动同步</h4><p>我的设想是这样，既然两个仓库冲突了，那我删掉其中一个。那不就铁定不会冲突了吗。</p>
<p>呵呵，理想很美好。现实总是。。。啪啪啪打脸呢。</p>
<p>我已经把本地仓库删光光，然后复制了远程的到本地，重新建立了他们的连接。竟然还是不行。</p>
<p>到底是哪里出问题了呢？？</p>
<p>难道是我本地空间不足，一些文件上传了云，所以本地没有，导致有冲突吗？</p>
<p>下面是疯狂提示：</p>
<p>![image-20201113021509915](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201113021509915.png)</p>
<p>![image-20201113021554349](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201113021554349.png)![image-20201113021611872](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201113021611872.png)</p>
<p>不不不，应该不会。。。。吧</p>
<h3 id="猜想-–-为啥会出现这些问题呢？"><a href="#猜想-–-为啥会出现这些问题呢？" class="headerlink" title="猜想 – 为啥会出现这些问题呢？"></a>猜想 – 为啥会出现这些问题呢？</h3><p>应该就是远程仓库和本地仓库同步有问题，导致版本冲突。那么为啥同步会有问题呢？</p>
<h4 id="猜测-1：密钥🔑不对，远程链接不上"><a href="#猜测-1：密钥🔑不对，远程链接不上" class="headerlink" title="猜测 1：密钥🔑不对，远程链接不上"></a>猜测 1：密钥🔑不对，远程链接不上</h4><h4 id="猜测-2-本地仓库和远程仓库之间没同步好"><a href="#猜测-2-本地仓库和远程仓库之间没同步好" class="headerlink" title="猜测 2:  本地仓库和远程仓库之间没同步好"></a>猜测 2:  本地仓库和远程仓库之间没同步好</h4><h4 id="猜测-3-难道是我本地空间不够？"><a href="#猜测-3-难道是我本地空间不够？" class="headerlink" title="猜测 3:  难道是我本地空间不够？"></a>猜测 3:  难道是我本地空间不够？</h4><h3 id="验证猜想-–-来嘛，咱一个一个来"><a href="#验证猜想-–-来嘛，咱一个一个来" class="headerlink" title="验证猜想 – 来嘛，咱一个一个来"></a>验证猜想 – 来嘛，咱一个一个来</h3><p>问题总是一个一个一个一个一个一个一个…一个一个一个一被解决的嘛。</p>
<p>别怕，先来验证第一个猜想。</p>
<h4 id="是不是因为公钥的问题，去查查看"><a href="#是不是因为公钥的问题，去查查看" class="headerlink" title="是不是因为公钥的问题，去查查看"></a>是不是因为公钥的问题，去查查看</h4><ul>
<li>```bash<br>1.ssh-keygen -t rsa -C “<a href="mailto:&#121;&#x6f;&#x75;&#x72;&#101;&#x6d;&#x61;&#105;&#108;&#x40;&#101;&#120;&#x61;&#109;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#109;">&#121;&#x6f;&#x75;&#x72;&#101;&#x6d;&#x61;&#105;&#108;&#x40;&#101;&#120;&#x61;&#109;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#109;</a>” # 创建SSH-Key<br>将本地用户目录（用户目录/.ssh/id_rsa.pub）的ssh公钥添加到GitHub中<br>2.git bash中输入<br>cat ~/.ssh/id_rsa.pub<br>复制好出现的内容<br>3.打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。<br>把刚刚复制的内容全部黏贴到框中，点击确定保存。<h1 id="以上步骤我以前已经做过了。也就是说我已经在github添加了我的ssh。我现在只要验证下是不是还连接成功。"><a href="#以上步骤我以前已经做过了。也就是说我已经在github添加了我的ssh。我现在只要验证下是不是还连接成功。" class="headerlink" title="以上步骤我以前已经做过了。也就是说我已经在github添加了我的ssh。我现在只要验证下是不是还连接成功。"></a>以上步骤我以前已经做过了。也就是说我已经在github添加了我的ssh。我现在只要验证下是不是还连接成功。</h1>（这个ssh链接是和我的整个github的）<br>4输入ssh -T <a href="mailto:&#103;&#105;&#x74;&#64;&#x67;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#x6d;">&#103;&#105;&#x74;&#64;&#x67;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#x6d;</a>，（ssh -T <a href="mailto:&#103;&#x69;&#x74;&#64;&#x63;&#111;&#x64;&#101;&#46;&#97;&#108;&#x69;&#121;&#x75;&#x6e;&#46;&#99;&#x6f;&#109;">&#103;&#x69;&#x74;&#64;&#x63;&#111;&#x64;&#101;&#46;&#97;&#108;&#x69;&#121;&#x75;&#x6e;&#46;&#99;&#x6f;&#109;</a> ssh -T git@<a href="https://github.com/wenjialu/wenjialu.github.io%EF%BC%89">https://github.com/wenjialu/wenjialu.github.io）</a><br>如果如下图所示，出现我的用户名，那就成功了。<br>也可以直接进行项目的克隆或提交进行测试。我的建议是，在配置完成后，对各个平台都进行一次链接测试。<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>- 可以看到，我已经与我的github建立了远程联系了：![image-20201113010754206](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201113010754206.png)<br><br>- 就是好像和仓库的ssh连接有些问题，但是git里面又已经加了这个仓库了。<br><br>- ![image-20201113011658853](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201113011658853.png)<br><br>- ![image-20201113012049666](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201113012049666.png)<br><br>暂且认为这个是没问题的吧。继续验证下一个猜想。<br><br><br><br>#### 本地仓库和远程仓库之间没同步好？<br><br>**那我就重新建立一次远程连接嘛**<br><br>```zsh<br>git init # 初始化本地仓库<br>git add ./ # 将文件添加到待提交区域<br>git commit -m “提交信息” # 提交<br>使用GitHub创建仓库（new Repository）<br>ssh-keygen -t rsa -C “youremail@example.com” # 创建SSH-Key<br>将本地用户目录（用户目录/.ssh/id_rsa.pub）的ssh公钥添加到GitHub中<br>git remote add origin git@github.com:XXXX.git # 将远程仓库与本地仓库建立连接<br>git pull origin master –allow-unrelated-histories # 首先将远程仓库的文件pull下来<br>#如果执行这句命令时，出现了“ couldn’t find remote ref –allow-unrelated-histories”的错误，输入如下命令即可解决：<br>​```git pull --rebase origin master<br>​```git push origin master<br>git push origin master # 将本地提交同步到远程仓库<br></code></pre></td></tr></table></figure></li>
</ul>
<p>注意那个绿色的代码，重大突破来咯！！！</p>
<p>当我用那行绿色代码解决error的时候，这个解决error的语句也出现了error。。</p>
<p>![image-20201113020540424](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201113020540424.png)</p>
<p>当我搜索解决方案的时候，stackoverflow[<a href="https://stackoverflow.com/questions/16064513/git-fatal-unable-to-write-new-index-file]%E4%B8%8A%E7%9A%84%E8%BF%99%E4%BD%8D%E5%93%A5%E4%BB%AC%E4%B8%80%E4%B8%8B%E9%81%93%E7%A0%B4%E4%BA%86%E9%97%AE%E9%A2%98%E7%9A%84%E5%85%B3%E9%94%AE%E3%80%82">https://stackoverflow.com/questions/16064513/git-fatal-unable-to-write-new-index-file]上的这位哥们一下道破了问题的关键。</a></p>
<p>![image-20201113020424628](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201113020424628.png)</p>
<p>喵个叽 果然和我磁盘空间脱不了关系。</p>
<h4 id="磁盘空间不足"><a href="#磁盘空间不足" class="headerlink" title="磁盘空间不足"></a>磁盘空间不足</h4><p>我感觉我快接近问题的本质了！！！</p>
<p>我再分析下其他人的回答，好像这个空间是服务器端，也就是github那边的问题。和我设想的本地空间不足好像有点不一样啊。</p>
<p>再看这位的回答：</p>
<p>![image-20201113021244491](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201113021244491.png)</p>
<p>妈呀我都快激动哭了，这么朋友也是由这个问题导致的commit不了。</p>
<p>那么我赶紧来试试这个命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">chmod -RN /path/to/repo <span class="hljs-comment">#别忘了把/path/to/repo改成你本地仓库的地址哦</span><br></code></pre></td></tr></table></figure>

<p>然后我们继续把刚刚中断的命令敲完：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git pull --rebase origin master <span class="hljs-comment">#可能会有一些小冲突，按照提示走就行了。</span><br>git push origin master<br></code></pre></td></tr></table></figure>

<p>上图！啊哈哈 虽然有些安全性上的小问题，但是我就先无视了。</p>
<p>![image-20201113022526522](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201113022526522.png)</p>
<p>完结撒花～～～～～！！</p>
<p>什么？   你以为这就完结了，还是太天真了哦。</p>
<p>未完待续。。。。。。</p>
<p>嵌套git</p>
<p>![image-20201118102445779](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201118102445779.png)</p>
<h4 id="小插曲："><a href="#小插曲：" class="headerlink" title="小插曲："></a>小插曲：</h4><p>一开始把拉远程仓库的命令搞错了。</p>
<p>既不是 git  pull,  也不是 git pull master 🙅 。</p>
<p>正确的应该是 git pull origin master 🙆 ！</p>
<p>希望大家不要和我一样犯这个傻傻的错误哦。</p>
<p>![image-20201113023049984](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201113023049984.png)</p>
]]></content>
      <tags>
        <tag>Writing</tag>
      </tags>
  </entry>
  <entry>
    <title>Google Cloud 部署我的网站 (附宝塔面板安装教程)</title>
    <url>/hexo-blog/2021/01/23/Google-Cloud-%E9%83%A8%E7%BD%B2%E6%88%91%E7%9A%84%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>我曾经在github 上部署过我的个人网站，不过github上的静态网页已经越来越不能满足我对网站的需求了。</p>
<p>于是，我选择把整个网站迁移到自己的云服务器上。</p>
<p>如果你对我的网站感兴趣，可以点<a href="http://wenjialu.tech/">这里</a>参观。</p>
<p>以下是我的教程。</p>
<h3 id="安装宝塔面板"><a href="#安装宝塔面板" class="headerlink" title="安装宝塔面板"></a>安装宝塔面板</h3><p><strong>vm实例</strong>右侧有个<code>ssh</code>按钮，点击就可以进入到后台。</p>
<p>1 sudo - i</p>
<p>2 脚本安装 （一整行复制哦）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text"># My google cloud instance is Centos<br>Centos安装脚本 <br>yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh<br> <br>#My google cloud instance-1 is Debian<br>Debian安装脚本<br>wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; bash install.sh<br> <br>Ubuntu/Deepin安装脚本 <br>wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh<br> <br><br>Fedora安装脚本<br> wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; bash install.sh<br></code></pre></td></tr></table></figure>

<p>3 安装完成后记录下自己的宝塔地址和密码</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmyueb5t6pj30lk08nmyg.jpg"></p>
<p>4 浏览器登陆面板后，选择LNMP（推荐）</p>
<p>5 按照提示注册</p>
<p>安装完成～</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmytc9yq07j310j0l4q69.jpg"></p>
<p>要注意将vps的临时ip设置为静态ip，不然关机重启会导致ip发生变化（设置方法：vpc网络-&gt;外部ip地址-&gt;类型）</p>
<h3 id="添加站点"><a href="#添加站点" class="headerlink" title="添加站点"></a>添加站点</h3><p>Step1:  注册域名</p>
<p>hostinger 上挑一个自己喜欢的域名。</p>
<p>我花了10块钱在hostinger 上买了一个一年的域名 wenjia.tech</p>
<p>有了域名相当于你生产的“宝宝”有了名字，</p>
<p>但是宝宝光有名字不够啊，还得去公安局登记注册身份证号，</p>
<p>同理，我们的域名也需要经过一个叫 DNS 的服务认证，才能建立起 域名和ip 的一对一联系。</p>
<p>Step2: 解析域名</p>
<p> hostinger - DNS/Nameservers</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Name</th>
<th>Points to</th>
<th>Til</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>www</td>
<td>填写你的服务器 IP</td>
<td>300</td>
</tr>
</tbody></table>
<p>或者</p>
<p>打开<a href="https://help.aliyun.com/document_detail/29716.html">阿里云</a></p>
<p>DNS解析 <a href="https://dns.console.aliyun.com/?spm=5176.12901015.0.i12901015.7fc6525cUup6lY&amp;accounttraceid=d17d9f090e29430f9e46fae5c55b8f00vsgi#/dns/setting/wenjialu.tech">https://dns.console.aliyun.com/?spm=5176.12901015.0.i12901015.7fc6525cUup6lY&amp;accounttraceid=d17d9f090e29430f9e46fae5c55b8f00vsgi#/dns/setting/wenjialu.tech</a></p>
<p>到 hostinger - DNS/Nameservers - change nameservers</p>
<p>改成阿里云的 DNS 服务器</p>
<table>
<thead>
<tr>
<th><strong>ns1.alidns.com</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>ns2.alidns.com</strong></td>
</tr>
</tbody></table>
<p>Step3: 宝塔 – 网站 – 添加站点</p>
<p>把域名填进去</p>
<p>保存好数据库等信息。</p>
<p>Step4: 添加 ssl 证书</p>
<p><a href="https://wenjialu.github.io/hexo_blog/2021/01/25/%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%AB%99%E9%85%8D%E7%BD%AEssl%E8%AF%81%E4%B9%A6/">教程地址</a></p>
<p>接下来，可以根据自己的需求，选择自己所需的教程部分。</p>
<p>如果你以前已经有了网站，想迁移到这个新服务器上的，看上传宝塔。</p>
<p>如果是建站小白或者是想要一个新网站的，到安装插件部分。</p>
<h3 id="上传宝塔"><a href="#上传宝塔" class="headerlink" title="上传宝塔"></a>上传宝塔</h3><p>先把博客所在的文件夹 打包成<strong>压缩包</strong></p>
<p>到网站的根目录 www - wwwroot </p>
<p>依次点击：文件 - 上传</p>
<p>上传完成之后再解压就可以啦。</p>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>软件商店–宝塔插件 – 宝塔一键部署源码 </p>
<p>里面有很多中博客模版可以选择。</p>
<p>我推荐使用 wordpress, 口碑有保证。</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>添加 ssl 证书：<a href="https://wenjialu.github.io/hexo_blog/2021/01/25/%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%AB%99%E9%85%8D%E7%BD%AEssl%E8%AF%81%E4%B9%A6/">https://wenjialu.github.io/hexo_blog/2021/01/25/%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%AB%99%E9%85%8D%E7%BD%AEssl%E8%AF%81%E4%B9%A6/</a></p>
<p>阿里云ssl： <a href="https://yq.aliyun.com/articles/637307">https://yq.aliyun.com/articles/637307</a></p>
<p>部署网站：<a href="https://www.bilibili.com/video/av57100951/">https://www.bilibili.com/video/av57100951/</a></p>
<p>ssh： <a href="https://www.vediotalk.com/archives/606">https://www.vediotalk.com/archives/606</a></p>
]]></content>
      <tags>
        <tag>Google Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Google Cloud</title>
    <url>/hexo-blog/2021/01/15/Google-Cloud/</url>
    <content><![CDATA[<p>What I want to do:<br>I need a server to depoly my applications, such as websites.<br>I used to depoly my websites on Github Pages, but that only works for static pages and it has many limitations.</p>
<p>Why I use Google Cloud:<br>I now there are many companies could provide server service, such as Aliyun, HuaweiCloud, AWS, etc.<br>Most of they only provide 30-day trail.<br>Google Cloud, on the other hand, not only allows me to use it for free for a year but also give me 300 $ for trial, so I choose it.</p>
<p>How to use it:<br>It is quite easy as long as you have a Visa.</p>
<ol>
<li>Wisit its <a href="https://cloud.google.com/">website</a>. </li>
<li>Find “VM instance” from the left sidebar and click it.</li>
<li>Fill the information of your bill.</li>
<li>Select the configuration of your server.</li>
<li>Done!</li>
</ol>
]]></content>
      <tags>
        <tag>Server</tag>
      </tags>
  </entry>
  <entry>
    <title>Growth Hacking -- ins 篇</title>
    <url>/hexo-blog/2021/01/05/Growth%20Hacking%20--%20ins%20%E7%AF%87/</url>
    <content><![CDATA[<p>Ins 是个很多元的公域流量平台。 只要有一技之长/自己的特色，无论高矮胖瘦，都有可能成为红人。</p>
<p>我有朋友就通过持续在 ins 上输出高质量图片 而获得找上门的广告机会。</p>
<p>这就激发了我在 ins 上分享图片的想法。</p>
<p>因为我最近也是个热爱生活，喜欢拍照分享的人 ～ </p>
<p>与其只能让自己的私域流量圈子里的人看到，何不顺便分享给全世界？</p>
<p>于是随手打开 ins 逛了 一圈， 无论是朋友还是关注的名人，他们分享的照片都很出彩啊。</p>
<p>看来想脱颖而出不是那么简单的，还需要一些 growth hacking 的技巧。</p>
<p>以下是我根据达人分享总结的 ins 涨粉攻略: </p>
<p>step1.1: 确立自己的主题 ⭐️<br>最好是垂直领域的<br>“If you can’t be first in a category, set up a new category you can be first in.” 如果你无法成为某个细分领域的第一名，那就创造一个新的细分领域并尝试成为第一名。</p>
<p>step1.2: 写profile<br>明确告诉大家，我的主题是什么？ 能给关注者带来什么价值？</p>
<p>step2: <strong>每日</strong>更新照片。有时可以发发以前的老照片保持活跃度。</p>
<p>Tricks:<br>说在前面：<br>tricks 虽能带来流量，但能留住关注靠的是高质量内容！<br>如果自己的账号内容太少，很难做增长。建议至少有2-3页高质量、风格一致的内容后，再开始使用增长策略。</p>
<p>trick 1: 加热门 hashtag。<br>类似 Focalmark 的app。</p>
<p>可以非常轻松地为自己的照片加上相关主题的热门 hashtag，最大化照片的曝光度。</p>
<p>trick 2: 短时间内关注尽可能多的相同主题的优质账号。（会突然有很多粉丝）</p>
<p>tips：1）每小时不要超过 100 个</p>
<p>2）由于关注人数有上限</p>
<p>超过上限后，可以用类似“Followers Assistant” 的免费 APP（Android平台）分析关注的人有没有回关我，从而选择取消关注的对象。</p>
<p>trick 3: F4F ( follow for follow)<br>follow的人群要有针对性<br>@superkakarotto 用的最多、效果最好、且不会被Action Block(暂时没有遇到)的两个方式是「F4F和点赞评论粉丝主页。他一般的操作是打开与我相似的博主最近一条post，点开点赞列表，一口气关注30~50个点赞者，然后开始往下进入列表里其他用户的主页，点赞或发表评论。以我的经验，回关的效果是 关注&gt;评论&gt;点赞，成本是 评论&gt;点赞&gt;关注，因为关注连进入用户首页都不需要，只要在点赞列表就能一键关注，所以成本最低，效果最好，不会被封，这就是他认为F4F仍然是2020冷启动最好策略的原因」</p>
<p>trick 4：发 story<br>trick 5: 使用 ins 新功能<br>trick 6: 开通 insights</p>
<p>trick 7秘密武器–Telegram</p>
<p>telegram是ins增长神器。telegram上有很多特定主题的群聊，我们可以用搜群助手找到跟我们自身主题相关的群，然后在里面发言，推荐我们自己的ins。实测效果极佳！<br><a href="https://t.me/hao1234bot">https://t.me/hao1234bot</a><br>更新：欢迎大家加入基于Telegram的INS涨粉互助群：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">https://t.me/joinchat/Ep0gbQ9FGJeMRCokb_Sb8A<br></code></pre></td></tr></table></figure>

<p>加入方法：完整复制上方链接到telegram内打开即可。</p>
<p>3k - 4k 以上粉后可以实现自然增长。</p>
<p>资料💾：1. <a href="https://jarodise.com/instagram-600-followers-in-6-days-follow-unfollow-regrann/">https://jarodise.com/instagram-600-followers-in-6-days-follow-unfollow-regrann/</a><br>2. <a href="https://zhuanlan.zhihu.com/p/140049624">https://zhuanlan.zhihu.com/p/140049624</a>  @superkakarotto </p>
]]></content>
      <tags>
        <tag>growth hacking</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/hexo-blog/2021/01/06/Growth%20Hacking%20/</url>
    <content><![CDATA[<p>-–</p>
<p>title: Growth Hacking – general 篇</p>
<p>date: 2021-01-05 22:30:48</p>
<p>tags: growth hacking</p>
<p>-–</p>
<p>我在大理参加了自由职业者大会，参会者有旅行分享的头部大V，B站最火法语博主，大理好在的运营者，有400 万用户的独立软件开发者，清华大学新闻学毕业生等等。</p>
<p>一个内容创业者在创业初期最重要的工作有且只有三个：</p>
<p><strong>1.持续创作自己所选内容niche相关的高质量内容。</strong></p>
<p>2.将自己创作的内容通过广撒网的形式分发到各个内容平台和渠道，并通过受众反馈来确认自己内容受众最为集中的2-3个平台。</p>
<p>3.持续创作的同时要重视与受众的互动与反馈链，通过建立社群的方式增加粉丝粘性，慢慢地将路人转化成普通粉，并将普通粉转化成铁杆粉。**</p>
<p>这可能是一个非常漫长的过程，而且无法略过。我们不排除有些人会因为运气因素，在经历这个过程之前就实现爆红，但是如果没有<a href="https://mp.weixin.qq.com/s?__biz=MzIyMjAwNzAzNg==&mid=2650207361&idx=1&sn=19351e1cced0f629b6ebe2d13b34b5d8&chksm=f0364f12c741c604e2c26c5572110a2f40a1cadddc1aa0b97ee37b9fdc24bb5d13c357f3c14f&scene=21#wechat_redirect">1000个铁杆粉</a>作为根基，那么这种爆红也终将是昙花一现，</p>
<p>资源：<a href="https://jarodise.com/ultimate-guide-for-content-startup-in-2020/">https://jarodise.com/ultimate-guide-for-content-startup-in-2020/</a></p>
]]></content>
  </entry>
  <entry>
    <title>How I build this website with Hexo</title>
    <url>/hexo-blog/2020/09/23/How-I-build-this-website-with-Hexo/</url>
    <content><![CDATA[<p>折腾的来源：好看但是难搞的 the Space Cadet theme<br>npm install bootstrap@next<br>本模版灵感来源于 bootstrap ： <a href="https://getbootstrap.com/docs/4.0/examples/blog/">https://getbootstrap.com/docs/4.0/examples/blog/</a><br>npm install hexo-tag-bootstrap –save</p>
<p>渲染策略：<a href="https://blog.csdn.net/kinggoZhang/article/details/96192344">https://blog.csdn.net/kinggoZhang/article/details/96192344</a></p>
<p>主题排名：<br>我挑出来好看的<br><a href="https://github.com/huan-qiu/lemon-lime">https://github.com/huan-qiu/lemon-lime</a><br>Simple<br><a href="https://github.com/philippkeller/hexo-theme-twbootstrap">https://github.com/philippkeller/hexo-theme-twbootstrap</a><br>这个简约又好看，和我简历系列也很搭：<a href="https://www.iguan7u.cn/">https://www.iguan7u.cn/ </a>  下载地址 <a href="https://github.com/iGuan7u/Acetolog">https://github.com/iGuan7u/Acetolog</a></p>
<p><a href="http://www.swig.org/tutorial.html">http://www.swig.org/tutorial.html</a></p>
<p>这个有点bbc的风格，看上去很专业，而且侧边文章目录结构看的很清楚 <a href="https://itimetraveler.github.io/hexo-theme-hiero/">https://itimetraveler.github.io/hexo-theme-hiero/</a>  下载地址<a href="https://github.com/iGuan7u/Acetolog">https://github.com/iGuan7u/Acetolog</a><br>￼￼ Hiker主题预览</p>
<p>类似Twitter 和bootstrap适应的最好 <a href="https://github.com/wzpan/hexo-theme-freemind/">https://github.com/wzpan/hexo-theme-freemind/</a><br>geek 风格啊哈哈哈，就是文章不好看 <a href="https://geek.lc/">https://geek.lc/</a><br>这个首页好看， 但是太白了 <a href="https://siricee.github.io/hexo-theme-Chic/">https://siricee.github.io/hexo-theme-Chic/</a></p>
]]></content>
      <tags>
        <tag>tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>Intro Of the Sidebar Widgets</title>
    <url>/hexo-blog/2020/09/23/Intro-Of-the-Sidebar-Widgets/</url>
    <content><![CDATA[<p>Hey, this is actually a blog for reminding myself of the usage of the Sidebar Widgets.</p>
<p>The sidebar widgets are shown on the right side of my website. They includes “About”, “Tag”, “Tagcloud”, “archives” and “recent_posts”.</p>
<p>Please do not confused sidebar widgets with article types.</p>
]]></content>
      <tags>
        <tag>trail</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/hexo-blog/2020/11/18/LISP/</url>
    <content><![CDATA[<h1 id="LISP"><a href="#LISP" class="headerlink" title="LISP"></a>LISP</h1><p>Physics: limitation of really world</p>
<p>cs: just limitation of our mind</p>
<p><strong>techniques for controlling complexity</strong></p>
<p>Black-box abstraction:</p>
<p>不用管黑箱里面发生了什么</p>
<p>Conventional Interfaces 约定接口</p>
<p>元语言抽象</p>
<h2 id="rules"><a href="#rules" class="headerlink" title="rules"></a>rules</h2><h2 id="如何运用"><a href="#如何运用" class="headerlink" title="如何运用"></a>如何运用</h2>]]></content>
  </entry>
  <entry>
    <title>Mac顺滑启动Node.js项目指南</title>
    <url>/hexo-blog/2021/01/28/Mac%E9%A1%BA%E6%BB%91%E5%90%AF%E5%8A%A8Node.js%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p><strong>可视化</strong></p>
<p>建议可以用一个仪表盘来可视化管理vue项目</p>
<p>1 启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">vue ui<br></code></pre></td></tr></table></figure>

<p>tip：如果遇到报错：getaddrinfo ENOTFOUND localhost错误。</p>
<p>则：</p>
<p>sudo vim /etc/hosts , 并在 host里面加上 127.0.0.1 localhost</p>
<p>2 导入/新建项目 </p>
<p>如果项目已经有雏形的话，可以直接导入。然后点击右边的“在编辑器中打开”按钮，就会自动在 vscode 中打开你的项目代码，非常的方便好用。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gn9qohguo4j30yo09xaay.jpg"></p>
<p>3 管理项目</p>
<p>使用仪表盘，可以非常直观的管理项目的依赖、插件、配置等等。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gn9qshw2l0j311z0juwh8.jpg"></p>
<p>4 编译/发布项目</p>
<p>点开任务栏，甚至能帮助直接编译启动你的项目。</p>
<p>启动成功后，还会有详细的数据分析，如速度统计，资源占比分配是否合理等等，并给出具体的建议。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gn9qvx87smj31240j9adn.jpg"></p>
<p>原理：</p>
<p>-</p>
<p>api.js</p>
<p>Crud.js</p>
<p>index.vue</p>
<p>-</p>
<p>Router – index.vue</p>
<p><strong>配置：</strong></p>
<p>需要解决2个问题</p>
<p>1 Proxy问题：</p>
<p><strong>process.env</strong></p>
<blockquote>
<p>Nodejs 提供了 process.env API，它返回一个包含用户环境信息的对象。当我们给 Nodejs 设置一个环境变量，并且把它挂载在 process.env 返回的对象上，便可以在代码中进行相应的环境判断。</p>
</blockquote>
<p>windows下你要这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#node中常用的到的环境变量是NODE_ENV，首先查看是否存在 <br>set NODE_ENV <br>#如果不存在则添加环境变量 <br>set NODE_ENV=production <br>#环境变量追加值 set 变量名=%变量名%;变量内容 <br>set path=%path%;C:\web;C:\Tools <br>#某些时候需要删除环境变量 <br>set NODE_ENV=<br></code></pre></td></tr></table></figure>

<p><strong>永久配置</strong><br>右键(此电脑) -&gt; 属性(R) -&gt; 高级系统设置 -&gt; 环境变量(N)…</p>
<p>mac下你要这个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#node中常用的到的环境变量是NODE_ENV，首先查看是否存在<br>echo $NODE_ENV<br>#如果不存在则添加环境变量<br>export NODE_ENV=production<br>#环境变量追加值<br>export path=$path:/home/download:/usr/local/<br>#某些时候需要删除环境变量<br>unset NODE_ENV<br>#某些时候需要显示所有的环境变量<br>env<br></code></pre></td></tr></table></figure>





<p><strong>Mac必须要写 <a href="http://127.0.0.1/">http://127.0.0.1</a> 而不是 localhost ！！！</strong></p>
<p>即使host文件里面配置过 DNS 的关系也得这样写。</p>
<p>For windows:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-string">&quot;proxy&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;/auth/google&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;target&quot;</span>: <span class="hljs-string">&quot;localhost:8830/m&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>For Mac:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-string">&quot;proxy&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;/auth/google&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;target&quot;</span>: <span class="hljs-string">&quot;http://127.0.0.1:8830/m&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<p>2 请求超时：</p>
<p>请求超时，首先判断接口服务器是否启动，再去判断接口地址、端口、路径是否正确</p>
<p>我这些都没问题。</p>
<p>然后查看 axios：</p>
<p>scr - utils - request.js的文件</p>
<p>打开文件，在里面如下图所示更改一个地方即可，即把timeout的时间改长一些（比如 5000 改 90000），再重新打开项目获取数据会发现成功获取并且不报超时～</p>
<p>3页面直接显示空白<br>修改vue.config.js中publicPath为**’ ./ ‘**即可注意这里的publicPath 为build下</p>
<p>4 表单不显示</p>
<p>当后台服务器启动，其他表单能显示，唯独我自己写的表单加载不出来。</p>
<p>当后端服务器没有开启的时候，所有表单都是加载不出来的，因为请求找不到相应资源。</p>
<p>由此推断，是没有找到相应的路径，问题就出现在url上！</p>
<p>解决方案：</p>
<p>1 把后端Controller的访问url改成Round_Dict</p>
<p> api 和 user 间有循环应用，在pom中注释掉其中一个依赖就行了。</p>
<p>Q: SpringCloud启动出现 Could not locate PropertySource: I/O error on GET request for 解决](<a href="https://my.oschina.net/PTOldDriver/blog/3016037">https://my.oschina.net/PTOldDriver/blog/3016037</a>)</p>
<p>1.检测配置文件里是否有如果没有请加上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs \">spring:<br>  cloud:<br>    config:<br>      enabled: false<br></code></pre></td></tr></table></figure>

<p>2.如果是application.yml(application.properties)改为 bootstrap.yml（bootstrap.properties）即可.</p>
<p>Q</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">java.lang.IllegalStateException: Service id not legal hostname (poi_portrait_service)<br></code></pre></td></tr></table></figure>

<p>解决办法：</p>
<p>application.yml文件中的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">spring:<br>  application:<br>    name: poi_portrait_service<br></code></pre></td></tr></table></figure>











<p>资料：</p>
<p>环境变量process.env： <a href="https://github.com/frmachao/blog/issues/4">https://github.com/frmachao/blog/issues/4</a></p>
<p>element_ui: <a href="https://cloud.tencent.com/developer/section/1489884">https://cloud.tencent.com/developer/section/1489884</a></p>
]]></content>
  </entry>
  <entry>
    <title>React 简易教程</title>
    <url>/hexo-blog/2020/12/09/React%20%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>先做 react 介绍</p>
<p>亮点 和 局限。<br>优化：<br>PureComponent 是优化 React 应用程序最重要的方法之一，易于实施，只要把继承类从 Component 换成 PureComponent 即可，可以减少不必要的 render 操作的次数，从而提高性能，而且可以少写 shouldComponentUpdate 函数，节省了点代码。</p>
<p>和 vue区别</p>
<p>然后案例 smartbrain</p>
<h1 id="react-简易教程"><a href="#react-简易教程" class="headerlink" title="react 简易教程"></a>react 简易教程</h1><p>Component : 不仅包含html css 还有功能，可以之后被复用</p>
<p>就像搭乐高一样搭 Component</p>
<p>自上而下渲染，一个Component 节点修改，只有他孩子节点知道，父母节点不会知道。</p>
<p>具体啥prop在主js里设定，</p>
<p>组件js 的函数里面，prop只是个穿传去的参数 （所以具体prop是啥不知道，他只是个参数啊。具体的在主js里面定义），里面调用 this.prop.prop名</p>
<p>export</p>
<p>但凡要被import的文件 都要export</p>
<h2 id="Lifecycle-hooks"><a href="#Lifecycle-hooks" class="headerlink" title="Lifecycle hooks"></a>Lifecycle hooks</h2><p><a href="https://reactjs.org/docs/react-component.html">https://reactjs.org/docs/react-component.html</a></p>
<p>component </p>
<p>every time  auto triggered</p>
<h3 id="mounting"><a href="#mounting" class="headerlink" title="mounting"></a>mounting</h3><ul>
<li><a href="https://reactjs.org/docs/react-component.html#constructor"><strong>constructor()</strong></a></li>
<li><a href="https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops"><code>static getDerivedStateFromProps()</code></a></li>
<li><a href="https://reactjs.org/docs/react-component.html#render"><strong>render()</strong></a></li>
<li><a href="https://reactjs.org/docs/react-component.html#componentdidmount"><strong>componentDidMount()</strong></a></li>
<li>render()</li>
</ul>
<h3 id="updating"><a href="#updating" class="headerlink" title="updating"></a>updating</h3><h3 id="Unmounting"><a href="#Unmounting" class="headerlink" title="Unmounting"></a>Unmounting</h3><h2 id="Chirdren"><a href="#Chirdren" class="headerlink" title="Chirdren"></a>Chirdren</h2><scroll>

<p> 内部的内容就是它的chirldren</p>
</scroll>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function Scroll( props ) &#123;<br>    return (<br>     &lt;div style =&#123; &#123;overflowY:&quot;scroll&quot;, border: &quot;1px solid black&quot;, height: &quot;500px&quot;&#125;   &#125;&gt;<br>        &#123;props.children&#125;<br>     &lt;/div&gt;<br>    )<br>  &#125;;<br></code></pre></td></tr></table></figure>



<h2 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;<br>		<span class="hljs-comment">// 设置状态初始值（创参）</span><br>     <span class="hljs-title">constructor</span> (<span class="hljs-params"></span>)&#123;<br>				<span class="hljs-built_in">super</span>();<br>    		<span class="hljs-built_in">this</span>.state = initialStatexxx;<br>     &#125;<br><br>    <span class="hljs-comment">// 给状态赋值的函数 (形参)</span><br>    <span class="hljs-comment">// 都是函数, 设定完了之后在组件里面使用 （用参），最后在 render 里面被调用 （实参）</span><br>    onRouteChange = <span class="hljs-function">() =&gt;</span>&#123;<br>      <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">route</span>: route&#125;);<br>    &#125;<br><br>    onXXX = <span class="hljs-function">() =&gt;</span>&#123;<br>      <br>    &#125;<br>    <br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">const</span> &#123;route, ...&#125; = <span class="hljs-built_in">this</span>.state;<br>  <span class="hljs-keyword">return</span>(<br>  )<br>&#125;<br>  <br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;<br></code></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>node.js</title>
    <url>/hexo-blog/2020/12/09/Server%20%E7%AE%80%E4%BB%8B%20%20(node.js)/</url>
    <content><![CDATA[<h1 id="node-js-（用作Server）"><a href="#node-js-（用作Server）" class="headerlink" title="node.js （用作Server）"></a>node.js （用作Server）</h1><p>allow  js run everywhere, not only brewer.</p>
<h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><p>Node -v 检查有没有安装</p>
<p>没有的话去官网安装一下就好了</p>
<p>(我目前安装的是 v12.13.1 版本)</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>终端 node；</p>
<p>就能写 js</p>
<p>Pocess.exit() 退出</p>
<p>小实验 （这次不直接在终端写了，而是用一个js文件存储js）：</p>
<p>创建一个script.js</p>
<p>Node script.js 就能运行</p>
<h3 id="globalThis"><a href="#globalThis" class="headerlink" title="globalThis"></a>globalThis</h3><p>就是 window object， 不过在浏览器以外(比如终端node模式下）也能使用。</p>
<h3 id="导包方式"><a href="#导包方式" class="headerlink" title="导包方式"></a>导包方式</h3><p><strong>commonJs modules way:</strong> </p>
<p>const xx = require(“./script.js”)</p>
<p>Module.exports = {</p>
<p>xxx = xxx</p>
<p>}</p>
<p>**Es6 way **(version 12 以上)</p>
<p>1 命名为mjs文件</p>
<p>Import/ export</p>
<p>2 用 npm init (-y)来创建一个package.json:</p>
<p>里面加上 “type”: “module”</p>
<p>Import/ export</p>
<h3 id="一些比较常用的包"><a href="#一些比较常用的包" class="headerlink" title="一些比较常用的包"></a>一些比较常用的包</h3><p>http</p>
<p>const xx = require(“http”)</p>
<p>Nodemon （会一直监听？server）</p>
<p>npm install nodemon –save-dev</p>
<ul>
<li>–save-dev (only use for development 部署的时候用)</li>
</ul>
<h2 id="用它来搭-server-（比较老的轮子：-http）"><a href="#用它来搭-server-（比较老的轮子：-http）" class="headerlink" title="用它来搭 server （比较老的轮子： http）"></a>用它来搭 server （比较老的轮子： http）</h2><h3 id="加-nodemon"><a href="#加-nodemon" class="headerlink" title="加 nodemon"></a>加 nodemon</h3><p>![image-20201120224438836](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201120224438836.png)</p>
<h3 id="用http-三行建立连接-（之后就不用http了，用express）"><a href="#用http-三行建立连接-（之后就不用http了，用express）" class="headerlink" title="用http 三行建立连接 （之后就不用http了，用express）"></a>用http 三行建立连接 （之后就不用http了，用express）</h3><p>测试连接</p>
<p>![image-20201120224603712](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201120224603712.png)</p>
<p>ps。要打开本地浏览器 <strong>访问localhost:3000.才会出现hear you。</strong></p>
<p><strong>访问一次出现一次</strong></p>
<h3 id="接受与响应"><a href="#接受与响应" class="headerlink" title="接受与响应"></a>接受与响应</h3><p>![image-20201120225020575](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201120225020575.png)</p>
<h3 id="响应返回json"><a href="#响应返回json" class="headerlink" title="响应返回json"></a>响应返回json</h3><p>传json回去</p>
<p>![image-20201120225338640](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201120225338640.png)</p>
<h2 id="新轮子：express-⭐️"><a href="#新轮子：express-⭐️" class="headerlink" title="新轮子：express ⭐️"></a>新轮子：express ⭐️</h2><p>19年最流行的server library： express</p>
<p>详情可以去看官方文档</p>
<pre><code>npm install express
</code></pre>
<h3 id="一样还是三行搭建好服务器。"><a href="#一样还是三行搭建好服务器。" class="headerlink" title="一样还是三行搭建好服务器。"></a>一样还是三行搭建好服务器。</h3><pre><code>const express = require(&quot;express&quot;);

const app = express();

app.listen(3000)
</code></pre>
<h3 id="middleware-中间件"><a href="#middleware-中间件" class="headerlink" title="middleware 中间件"></a>middleware 中间件</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>​    写在响应前</p>
<pre><code>app.use((req, res, next) =&gt; &#123;
    console.log(&quot;hi&quot;)
    next();
&#125;
) 
</code></pre>
<h4 id="常用中间件"><a href="#常用中间件" class="headerlink" title="常用中间件"></a>常用中间件</h4><h5 id="Body-parser-（新版本这个中间件被写进去了，就不用了）"><a href="#Body-parser-（新版本这个中间件被写进去了，就不用了）" class="headerlink" title="Body parser （新版本这个中间件被写进去了，就不用了）"></a>Body parser （新版本这个中间件被写进去了，就不用了）</h5><p>解析json的</p>
<pre><code>const bodyParse = require(&quot;body-parser&quot;)

const app = express();
// 中间件
app.use(bodyParse.json());
</code></pre>
<h3 id="返回响应"><a href="#返回响应" class="headerlink" title="返回响应"></a>返回响应</h3><pre><code>app.get(&quot;/&quot;,(req, res) =&gt; &#123;
    res.send(&quot;hellooo, get root&quot;)
&#125;
);
</code></pre>
<p>对比之前的，不需要设置相应头之类的了</p>
<p>![image-20201120231735301](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201120231735301.png)</p>
<h4 id="返回-json"><a href="#返回-json" class="headerlink" title="返回 json"></a>返回 json</h4><p>![image-20201120232020853](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201120232020853.png)</p>
<h4 id="返回静态页面-如html，-css"><a href="#返回静态页面-如html，-css" class="headerlink" title="返回静态页面 如html， css"></a>返回静态页面 如html， css</h4><pre><code>app.use( express.static(__dirname + &quot;/静态文件夹&quot;))
</code></pre>
<h4 id="Get-post-delete"><a href="#Get-post-delete" class="headerlink" title="Get post delete"></a>Get post delete</h4><p>然后用postman 测</p>
<h3 id="文件系统-fs"><a href="#文件系统-fs" class="headerlink" title="文件系统 fs"></a>文件系统 fs</h3><p>先下载 fs</p>
<p>fs 能读取文件</p>
<pre><code>const fs = requore(&quot;fs&quot;);
const file = fs.readFileSync(&quot;./hello.txt&quot;);
console.log(file.toString());
</code></pre>
<p>![image-20201121132027065](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201121132027065.png)</p>
<p>fs 能写文件</p>
<p>appendFile(“.txt”,”  “   )</p>
<p>writeFile( “ .txt”, “   “)</p>
<p>删除</p>
<p>Unlink</p>
<h2 id="Postman-测试"><a href="#Postman-测试" class="headerlink" title="Postman 测试"></a>Postman 测试</h2><p>query, params 请求可以在URL里面直接加 eg。localhost:3000/?name=xxx&amp;age=xx.  /:id</p>
<p>Server 里面能 get 到 req.query</p>
<p>header等就要在 postman 里面模拟了</p>
<h2 id="Restful"><a href="#Restful" class="headerlink" title="Restful"></a>Restful</h2><p>/名词</p>
<p>彩蛋：</p>
<p>Johnny-Five （用来做robot的 js 库）❤️</p>
]]></content>
      <tags>
        <tag>backend</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 数据库操作指南</title>
    <url>/hexo-blog/2021/01/20/SpringBoot-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="SpringBoot-连接数据库"><a href="#SpringBoot-连接数据库" class="headerlink" title="SpringBoot 连接数据库"></a>SpringBoot 连接数据库</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Spring中，数据从数据库到前端的流程：</p>
<p><strong>Jdbc配置（pom.xml，application.yml，cofig工程中：cof-dev.yal: spring.datasource:url?useSSL=false  usrname password ） –&gt;   <del>model</del>  HandlerMapping  –&gt; service(interface -&gt; impl(继承接口+@Override方法 ： 调用RoundDictExample（增删改查，验证）)) –&gt; controller –&gt; @responsebodey (包装响应 ResultStatus设置响应) –&gt; [swagger(/v2/api-docs)] 怎么返回实体类？？？–&gt; 前端</strong></p>
<p>ps. 我后期会画波脑图来更详细精确的分析。</p>
<p>Controller –&gt; service –&gt; mapper</p>
<p> 其中：  DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p>
<p> 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">model （HandlerMapping ）<br><br>			 -- domain: RoundDictExample (连接sql的增删改查，验证等功能,  里面的id统统要改成dict_id 或 dict_uuid); <br><br>        --persistence:  RoundDictMapper.xml,   RoundDictMapper (建立数据库与java代码的映射)<br><br></code></pre></td></tr></table></figure>



<p>【可以对照着这张图来康】</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn0cadg3yjj30jn0a2gq6.jpg"></p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h3><ul>
<li>本地远程连接数据库<br>注意: 使用远程连接时,使用的连接用户和该用户现在的ip地址应该是远程数据库中允许的用户和允许的ip,否则是不允许连接的.<ul>
<li><code>终端：mysql -Pxx -hxxx -uroot -p</code></li>
<li>图形化界面：Navicat / SQLyog</li>
</ul>
</li>
</ul>
<h3 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>理清楚从发送请求到数据被处理的流程：</p>
<p>发送请求 –&gt; DispatcherServlet （–doDispatc）—–。。。controller –&gt; <strong>responseMessage类</strong> (各种方法)—&gt;</p>
<p>  controller –&gt; coreController  (各种方法)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">... 省略部分代码....<br><span class="hljs-comment">// Actually invoke the handler.</span><br>mv = ha.handle(processedRequest, response, mappedHandler.getHandler());<br>... 省略部分代码<br></code></pre></td></tr></table></figure>

<p>Spring MVC会根据请求URL的不同，配置的RequestMapping的不同，为请求匹配不同的HandlerAdapter。</p>
<p>比如对于请求地址：<a href="http://127.0.0.1:8888/hello/test1?id=98%E5%8C%B9%E9%85%8D%E5%88%B0%E7%9A%84HandlerAdapter%E6%98%AFHttpRequestHandlerAdapter%E3%80%82">http://127.0.0.1:8888/hello/test1?id=98匹配到的HandlerAdapter是HttpRequestHandlerAdapter。</a></p>
<p>我们直接进入到HttpRequestHandlerAdapter中看下这个类的handle方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Copy<span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    ((HttpRequestHandler) handler).handleRequest(request, response);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><h5 id="postman"><a href="#postman" class="headerlink" title="postman"></a>postman</h5><h5 id="吹爆-Swagger-超好用"><a href="#吹爆-Swagger-超好用" class="headerlink" title="吹爆 Swagger 超好用"></a>吹爆 Swagger 超好用</h5><p>List： 返回的是分页的结果！！！！！！</p>
<p>action可能在父类里面，娃娃它的父类。</p>
<p>**getDocumentation()**方法，发现其实就是返回了一个Swagger对象（参数信息都存在Swagger对象的definitions属性里</p>
<p> [org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping] </p>
<ul>
<li><p>Mapped “{[/m/add],methods=[POST]}” onto public com.jj.api.vo.ResponseMessage&lt;java.lang.Integer&gt; com.jj.red.packet.user.admin.controller.RoundDictController.add(com.jj.red.packet.user.mybatis.domain.RoundDict)</p>
</li>
<li><p>.定义统一返回数据格式</p>
<ul>
<li>```<br>public class ResponseFormat {<pre><code>private static Map&lt;Integer,String&gt; messageMap = Maps.newHashMap();
//初始化状态码与文字说明
static &#123;
    /* 成功状态码 */
    messageMap.put(200, &quot;成功&quot;);

    /* 服务器错误 */
    messageMap.put(1000,&quot;服务器错误&quot;);

    /* 参数错误：10001-19999 */
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br><br><br>​	![](https://tva1.sinaimg.cn/large/008eGmZEgy1gn1lh25fhlj30o10gbtb1.jpg)<br><br><br><br><br><br><br><br><br><br>####  问题：<br><br>##### 访问获得404 <br><br>* 根据原理可知：我调用的接口不存在/没找到，Spring直接将Response的errorStatus状态设置成1，将http响应码设置为500或者404。 -- 继承BasicErrorController 就可以覆盖原有的错误处理方式。<br><br>* 根据报错也可以验证：<br><br></code></pre></td></tr></table></figure>
java.lang.IllegalArgumentException: Invalid character found in the request target. The valid characters are defined in RFC 7230 and RFC 3986<pre><code>  at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:479)
  at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:684)
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>  可能性：<br><br>1 TestCase测试Impl类的方法没有问题，但是Swgger和前端调用接口就会报404错误：<br><br>这是因为我之前把接口的注解@RestController 改成了@Controller。<br><br>改回来就好了。<br><br></code></pre></td></tr></table></figure>
import org.springframework.web.bind.annotation.RestController;<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>**@RestController**  （相当于@Controller + @ResponseBody 后者是方法级的注解）<br><br>tips：1 如果使用@RestResultController，如果返回值是String类型就存在指向性问题，返回String类型，指向的地址是String字符串的地址，因此前端http访问我的接口会报404.<br><br>​          2 也可以尝试在接收参数里加上 HttpServletResponse response<br><br>2<br><br>可能是jar包的问题<br><br>Artificial -- lib<br><br>  新手在刚接触springboot的时候，可能会出现访问请求404的情况，代码怎么看都是对的，但就是404。<br><br>  在十分确定代码没问题的时候，可以看下自己的包是不是出问题了，什么意思么？<br><br>  答案：SpringBoot 注解 @SpringBootApplication 默认扫描当前类的同包以及子包下的类； 如：启动程序在包名  com.yang.test.ymkribbonconsumer下，则会查找所有 com.yang.test.ymkribbonconsumer下的文件以及 com.yang.test.ymkribbonconsumer 下的所有子包里面的文件。<br><br>* x<br><br>  * xxMapper.xml 里面应该写的表名而不是数据库名。<br><br>* ~~JDBC Connection XXX will not be managed by Spring~~和SqlSession was not registered for synchronization because synchronization is not active<br><br>  意思是相关操作没有被事务管理起来，虽不影响项目功能正常使用，可每次启动看到这堆警告，导致强迫证又犯了，有一种非除之而后快件的冲动，于是检查配置文件中事务配置的部分，又上网搜索，经过一番测试，终于消除这些警告，下面是解决的过程。<br><br>  可看 https://www.codenong.com/cs106354150/<br><br>在db.properties里配置的username和passowrd是以前的一个项目的账户，那个账户的权限只有一个sms数据库，而那个账户没有我当前测试的xzl数据库的权限。<br><br>## <br><br>新建了一个有当前测试库权限的数据库用户，或者直接用root来测试。<br>链接：https://www.jianshu.com/p/259ce2ec91d3<br><br>##### 发出请求：连接数据库，响应：连接成功啦，却返回null，而没有返回实体类。<br><br>## <br><br><br><br>* Error parsing HTTP request header<br><br></code></pre></td></tr></table></figure>
o.apache.coyote.http11.Http11Processor:Error parsing HTTP request header</li>
</ul>
</li>
</ul>
<p>Note: further occurrences of HTTP request parsing errors will be logged at DEBUG level.</p>
<p>java.lang.IllegalArgumentException: Invalid character found in the request target. </p>
<p>The valid characters are defined in RFC 7230 and RFC 3986</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>目前，可以确定的是，该报错是由于url中有非法字符导致的，解决方法有<br><br>&gt; - 请求url中别有奇奇怪怪的字符，老老实实不好吗 使用了不安全字符，他们直接放在Url中的时候，可能会引起解析程序的歧义。如<br>&gt;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>  { } | \ ^ [ ] ` ~ % # 等<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>- 使用tomcat7.0.69以前的版本，这些版本不对请求头进行检验<br><br>- 不想降低tomcat版本？那就对特殊字符进行转义，嗯确实有点麻烦<br><br>- if you are not accidentally requesting with HTTPS protocol instead of HTTP protocol. If you don&#x27;t configure SSL on Tomcat and you send HTTPS request, it will result to this weird message..<br><br>## SpringMVC 架构<br><br>### what：<br><br>![](https://tva1.sinaimg.cn/large/008eGmZEgy1gn0b9z0016j30jm0d5n1u.jpg)<br><br><br><br>**M：model**<br><br>jojo 建数据库<br><br>dao (vo value object 拆的更细的的实体类)增删改查<br><br>servive<br><br>**V：view**<br><br>**C：controller**<br><br>接收用户请求，交给模型处理，把模型处理完的数据返回给视图。<br><br>一般来说是java类<br><br><br><br><br><br>后端项目结构主要是MC，即 Model + Controller。<br><br>举例：<br><br>&lt;img src=&quot;https://tva1.sinaimg.cn/large/008eGmZEgy1gmyudci33oj307b05dq3l.jpg&quot;  /&gt;<br><br>![](https://tva1.sinaimg.cn/large/008eGmZEgy1gn0am3mgujj306806mmxj.jpg)<br><br>admin文件夹: 管理员用户 - VO  + -Controller<br><br>整个文件夹：-( mybatis + service ) + -Controller<br><br><br><br><br><br><br><br>### how：<br><br>Spring的核心：servlet<br><br>![](https://tva1.sinaimg.cn/large/008eGmZEgy1gn0cadg3yjj30jn0a2gq6.jpg)<br><br>只有红框部分需要自己写，其他spring都帮忙做掉了。<br><br>234 找请求url对应的类处理器<br><br>5678 找并返回了数据库的数据。<br><br>91011 拿到数据库数据，拼接url，去找对应的前端视图。<br><br></code></pre></td></tr></table></figure><br>SpringMVC流程：<br>1、 用户发送请求至前端控制器 DispatcherServlet。<br>2、 DispatcherServlet收到请求调用HandlerMapping处理器映射器。<br>3、 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。<br>4、 DispatcherServlet调用HandlerAdapter处理器适配器。<br>5、 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。<br>6、 Controller执行完成返回ModelAndView。<br>7、 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。<br>8、 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。<br>9、 ViewReslover解析后返回具体View。<br>10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。<br>11、 DispatcherServlet响应用户。</p>
</blockquote>
<p>```</p>
<p>====</p>
<p>Selevlet</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn0be8se1mj30gd0e277r.jpg"></p>
<p>dispatcherservlet</p>
<p>![](/Users/lujiawen/Library/Application Support/typora-user-images/image-20210125223734010.png)</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn0bidh5swj30ov0c0q8d.jpg"></p>
<p>鼻祖：selvelet</p>
<p>实现 xxx（request, response)</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn0bk36cdoj30pd0bc44a.jpg"></p>
<p>资源：</p>
<p>DispatcherServlet : <a href="https://blog.csdn.net/xyx_hfut/article/details/104914200">https://blog.csdn.net/xyx_hfut/article/details/104914200</a> ⭐️</p>
<p>Spring自动注解原理：<a href="https://juejin.cn/post/6844904009577267207">https://juejin.cn/post/6844904009577267207</a></p>
<p>Spring后端到数据库操作：<a href="https://segmentfault.com/a/1190000010208184">https://segmentfault.com/a/1190000010208184</a></p>
<p>Springboot集成Mybatis全流程: <a href="https://blog.csdn.net/weixin_42322648/article/details/105063601?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/weixin_42322648/article/details/105063601?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&amp;spm=1001.2101.3001.4242</a></p>
<p>从404讲起发送请求返回请求的过程：<a href="https://www.cnblogs.com/54chensongxia/p/14007696.html">https://www.cnblogs.com/54chensongxia/p/14007696.html</a> ⭐️</p>
<p>404注解： <a href="https://blog.csdn.net/weixin_40160720/article/details/86601556">https://blog.csdn.net/weixin_40160720/article/details/86601556</a></p>
<p>写不好就会引起 404 的注解们的剖析大全： <a href="https://juejin.cn/post/6844903893734785037">https://juejin.cn/post/6844903893734785037</a> ⭐️</p>
<p>uuid 设为long会带来什么问题： <a href="https://www.jianshu.com/p/d7d63696eb89">https://www.jianshu.com/p/d7d63696eb89</a></p>
<p>Swagger: <a href="https://www.codenong.com/cs107102063/">https://www.codenong.com/cs107102063/</a></p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat on Google Cloud</title>
    <url>/hexo-blog/2021/01/15/Tomcat%20on%20Google%20Cloud/</url>
    <content><![CDATA[<p>What I want to do:<br>To deploy my webiste which is written by Jave, I also need to install jdk and tomcat on the Cloud.</p>
<p>What is Tomcat:</p>
<p>How to do it:<br>ssh<br><a href="https://www.jianshu.com/p/1a7ee8cbf665">https://www.jianshu.com/p/1a7ee8cbf665</a></p>
<p>Improvment:<br>use a visualable interface： 宝塔, which is easier to use.<br><a href="https://zhuanlan.zhihu.com/p/124133187">https://zhuanlan.zhihu.com/p/124133187</a></p>
]]></content>
      <tags>
        <tag>Server</tag>
      </tags>
  </entry>
  <entry>
    <title>about 50 projects</title>
    <url>/hexo-blog/2021/01/11/about-50-projects/</url>
    <content><![CDATA[<p>I am going to build 50 interesting fontend projects and update the tutorials of them.<br>All those projects would be used in my personal websites to make it greater.<br>LOL</p>
]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>electron</title>
    <url>/hexo-blog/2020/12/09/electron/</url>
    <content><![CDATA[<p>Electron 是一个框架，可以让您使用 JavaScript, HTML 和 CSS 创建桌面应用程序。 然后这些应用程序可以打包在macOS、Windows和Linux上直接运行，或者通过Mac App Store或微软商店分发。</p>
<p>通常，您使用每个操作系统特定的本地应用程序框架为操作系统 (OS)创建一个桌面应用程序。 Electron 可以在使用您已经知道的技术后写入您的应用程序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">sudo npm install -g electron --unsafe-perm=<span class="hljs-literal">true</span> --allow-root<br></code></pre></td></tr></table></figure>



<p>&gt; <a href="mailto:&#x65;&#x6c;&#101;&#x63;&#x74;&#114;&#111;&#110;&#x40;&#x39;&#x2e;&#x34;&#x2e;&#48;">&#x65;&#x6c;&#101;&#x63;&#x74;&#114;&#111;&#110;&#x40;&#x39;&#x2e;&#x34;&#x2e;&#48;</a> postinstall /usr/local/lib/node_modules/react-devtools/node_modules/electron</p>
<p>&gt; node install.js</p>
<p>官方文档：</p>
<p><a href="https://www.electronjs.org/docs/tutorial/quick-start#create-a-basic-application">https://www.electronjs.org/docs/tutorial/quick-start#create-a-basic-application</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>liunx服务器 上的各种操作</title>
    <url>/hexo-blog/2021/01/16/liunx%E6%9C%8D%E5%8A%A1%E5%99%A8%20%E4%B8%8A%E7%9A%84%E5%90%84%E7%A7%8D%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>liunx 命令大全： <a href="https://www.runoob.com/linux/linux-command-manual.html">https://www.runoob.com/linux/linux-command-manual.html</a></p>
<p>1 安装 jdk 包</p>
<p>第一种：已经安装好了，那么解压就行了</p>
<p>比如 Jdk包是rmp格式的，怎么解压呢。</p>
<p>要先转换成cpio格式：</p>
<p>rpm2cpio  xxxx.rpm | cpio -idv</p>
<p>第二种：去oracle官网下载</p>
<p>选择合适的liunx版本jdk8</p>
<p>那么怎么知道合不合适呢，</p>
<p>查看getconf LONG_BIT</p>
<p>如果显示32，则是32位的Linux系统，如果显示64，则是64位的Linux系统。这里是64位的，所以下载<strong>Linux x64</strong>，如下图：</p>
<p>![image-20210116181806625](/Users/lujiawen/Library/Application Support/typora-user-images/image-20210116181806625.png)</p>
<p>详见 <a href="https://zhuanlan.zhihu.com/p/94010951">https://zhuanlan.zhihu.com/p/94010951</a></p>
<p>ok, jdk装好了，</p>
<p>接下来配置环境变量。</p>
<p>2  配置环境变量</p>
<p>2.1 找到相应的文件</p>
<p>在.bashrc 或者 .bash_profile 里面配置，由于不知道具体叫啥名字</p>
<p>cd ~</p>
<p>ls -a显示全部文件，包括隐藏文件</p>
<p>2.2 添加环境变量</p>
<p>注意啦，这里 open 是打不开的，要用vim编辑器</p>
<p>Vim .bashrc</p>
<p>输入以下内容（ps：JAVA_HOME 路径写你自己的java安装路径 ）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">#set java environment<br>JAVA_HOME=/root/usr/java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span><br>CLASS_PATH=.:$JAVA_HOME/lib/<br>PATH=$PATH:$JAVA_HOME/bin<br>export JAVA_HOME CLASS_PATH PATH<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">export JAVA_HOME=/root/usr/java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span><br>export JRE_HOME=$&#123;JAVA_HOME&#125;/jre  <br>export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib  <br>export  PATH=$&#123;JAVA_HOME&#125;/bin:$PATH<br></code></pre></td></tr></table></figure>



<p>![image-20210116175250183](/Users/lujiawen/Library/Application Support/typora-user-images/image-20210116175250183.png)</p>
<p>关于vim的使用：打开后按i就可以进入编辑模式，在文件最后加上环境变量配置内容按exit退出编辑模式返回命令模式输入:wq保存并退出vim</p>
<p>2.3 刷新一下使它生效</p>
<p>source ~/.bashrc</p>
<h2 id="打开-jar-包"><a href="#打开-jar-包" class="headerlink" title="打开 jar 包"></a>打开 jar 包</h2><p>假设Linux服务上已经有了打好的jar包，下面介绍几种常用的部署方式：</p>
<p><strong>1、java -jar启动方式。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">java -jar *.jar<br>复制代码<br></code></pre></td></tr></table></figure>

<p>此中方式只会运行在当前窗口，当关闭窗口或断开连接，jar程序就会结束。</p>
<p>![image-20210116182734012](/Users/lujiawen/Library/Application Support/typora-user-images/image-20210116182734012.png)</p>
<p><strong>2、nohup启动方式。（推荐）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># nohup: 不挂断的运行命令<br># &amp;：后台运行<br># &gt;: 日志重定向输出到<br>nohup java -jar *.jar &gt;jarLog.txt &amp;<br>复制代码<br></code></pre></td></tr></table></figure>

<p><strong>3、注册为Linux服务（推荐）</strong></p>
<ul>
<li>首先需要现修改pom中spring-boot-maven-plugin配置，其实spring boot 打成jar包以后，是可以直接像shell脚本一样直接运行的，要实现这样可以直接运行，pom.xml 的build节点需要增加这样的配置：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br></code></pre></td></tr></table></figure>

<p>作者：BothEyes1993<br>链接：<a href="https://juejin.cn/post/6844904052153647111">https://juejin.cn/post/6844904052153647111</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>I am trying to run java command in linux server when I tried to run java I got some error-</p>
<blockquote>
<p>Error occurred during initialization of VM</p>
<p>Could not reserve enough space for object heap</p>
<p>Could not create the Java virtual machine.</p>
</blockquote>
<p>memory space is -</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">free -m<br></code></pre></td></tr></table></figure>



<p>Increase the amount of system resources in /etc/security/limits.conf, and then issue the “ulimit” command to check that the new resource limit has been changed to “unlimited”.</p>
]]></content>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/hexo-blog/2021/01/09/nvm%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p>nvm</p>
<p>What:</p>
<p><code>nvm</code> as a mechanism for managing node versions</p>
<p>官方文档：  <a href="https://github.com/nvm-sh/nvm">https://github.com/nvm-sh/nvm</a></p>
<p>To switch Node.js from <code>node@4.4.7</code> to <code>node@8.9.1</code> i have used following command:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">nvm install v8<span class="hljs-number">.9</span><span class="hljs-number">.1</span><br>nvm use v8<span class="hljs-number">.9</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure>





<p>Problems:</p>
<p>-bash: nvm: command not found</p>
<ol>
<li>Before installing <code>nvm</code>, run this in terminal: <code>touch ~/.bash_profile</code></li>
<li>After, run this in terminal:<br><code>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash</code></li>
<li><strong>Important…</strong> - DO NOT forget to <em>Restart</em> your terminal <strong>OR</strong> use command <strong><code>source ~/.nvm/nvm.sh</code></strong> (this will refresh the available commands in your system path).</li>
<li>In the terminal, use command <code>nvm --version</code> and you should see the version</li>
</ol>
<p>nvm ls 出错</p>
<p>在终端输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">export NVM_DIR=&quot;$HOME/.nvm&quot;<br>[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm<br></code></pre></td></tr></table></figure>







<p>Q：不识别es6 中的 … 语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 代码举例<br>const opts = &#123;<br><br>      binary: typeof data !== &#x27;string&#x27;,<br><br>      mask: !this._isServer,<br><br>      compress: true,<br><br>      fin: true,<br><br>      ...options<br><br>    &#125;;<br></code></pre></td></tr></table></figure>



<p>A：安装 babel 转换插件</p>
<p>babel-transform-object-rest-spread</p>
<p> npm install –save-dev babel-cli babel-preset-es2015 babel-preset-es2017</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">npm install babel-preset-stage-<span class="hljs-number">0</span> --save-dev<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm install @babel/core @babel/register @babel/preset-env --save-dev<br></code></pre></td></tr></table></figure>

<p>资源：</p>
<p><a href="https://stackoverflow.com/questions/16904658/node-version-manager-install-nvm-command-not-found">https://stackoverflow.com/questions/16904658/node-version-manager-install-nvm-command-not-found</a></p>
<p><a href="https://www.cnblogs.com/kengsan/p/6399858.html">https://www.cnblogs.com/kengsan/p/6399858.html</a></p>
<p><a href="https://segmentfault.com/q/1010000012941070">https://segmentfault.com/q/1010000012941070</a></p>
]]></content>
  </entry>
  <entry>
    <title>【手把手教学】用前端 react 来做一个机器人🤖️网站</title>
    <url>/hexo-blog/2021/12/13/react%20%20%E5%BB%BA%E9%80%A0%E6%9C%BA%E5%99%A8%E4%BA%BA%F0%9F%A4%96%EF%B8%8F%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="【手把手教学】用前端-react-来做一个机器人🤖️网站"><a href="#【手把手教学】用前端-react-来做一个机器人🤖️网站" class="headerlink" title="【手把手教学】用前端 react 来做一个机器人🤖️网站"></a>【手把手教学】用前端 react 来做一个机器人🤖️网站</h1><h2 id="先来看下最后的成果～～"><a href="#先来看下最后的成果～～" class="headerlink" title="先来看下最后的成果～～"></a>先来看下最后的成果～～</h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>先用 npm 安装 create-react-app </p>
<p>（ps. npm 是个很好用的前端包管理器。没有安装 npm 的小伙伴可以通过这个链接 <a href="https://www.npmjs.com/get-npm">https://www.npmjs.com/get-npm</a> 下载）</p>
</li>
<li><p>用 create-react-app 创建我们的机器人小项目，起名为 robofriends 。</p>
<p>（这一步react会帮我们装很多东西，比如依赖包啊什么的，可能要花点时间, 请耐心等待⌛️）</p>
</li>
</ol>
<h1 id="image-20201114143926433-Users-lujiawen-Library-Application-Support-typora-user-images-image-20201114143926433-png"><a href="#image-20201114143926433-Users-lujiawen-Library-Application-Support-typora-user-images-image-20201114143926433-png" class="headerlink" title="![image-20201114143926433](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201114143926433.png)"></a>![image-20201114143926433](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201114143926433.png)</h1><h3 id="装好了之后的界面是这样的-Happy-hacking"><a href="#装好了之后的界面是这样的-Happy-hacking" class="headerlink" title="装好了之后的界面是这样的 Happy hacking~"></a>装好了之后的界面是这样的 Happy hacking~</h3><p>![image-20201114144237710](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201114144237710.png)</p>
<h3 id="在终端：进入到刚刚装好的-robofriend-文件夹，可以看到相关依赖都装好啦～～"><a href="#在终端：进入到刚刚装好的-robofriend-文件夹，可以看到相关依赖都装好啦～～" class="headerlink" title="在终端：进入到刚刚装好的 robofriend 文件夹，可以看到相关依赖都装好啦～～"></a>在终端：进入到刚刚装好的 robofriend 文件夹，可以看到相关依赖都装好啦～～</h3><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>桌面上用你喜欢的idea打开整个文件夹，我用的是vscode（打开vscode直接拖动文件夹进去就好了）。</p>
<p>打开pakeage.json ， </p>
<p>看到 ”start“ 对应的就是“ react-scripts start” 启动脚本。</p>
<p>所以 ， 在终端运行 npm start 就能启动整个项目啦。</p>
<p>![image-20201114144822871](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201114144822871.png)</p>
<p>如果自动跳转到 localhost:3000 （见下图）</p>
<p>就是启动成功啦～</p>
<p>![image-20201114165308860](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201114165308860.png)</p>
<h2 id="项目结构初探"><a href="#项目结构初探" class="headerlink" title="项目结构初探"></a>项目结构初探</h2><p>来继续通过idea来看这个最初始的项目文件夹，</p>
<p>node_modules是自动帮我们下好的包，先不用去关心它。</p>
<p>public 里面有index.html，</p>
<p>src （source）文件夹就是一切 “魔法” 发生的地方啦，</p>
<p>我们会把最重要的js 还有 css 文件等放在这个文件夹里。</p>
<p><em>打开里面的 index.js。</em></p>
<p><em>ReactDom 这行代码 渲染了组件或者任何你写的东东到你指定的Dom上。</em></p>
<p><em>在这里我们渲染的是id为root的dom，可以去index.html里看，这是我们主体部分唯一的dom节点。</em></p>
<p><em>![image-20201114170054769](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201114170054769.png)</em></p>
<h2 id="写模块"><a href="#写模块" class="headerlink" title="写模块"></a>写模块</h2><h4 id="Demo-–-先做个小测试-～"><a href="#Demo-–-先做个小测试-～" class="headerlink" title="Demo – 先做个小测试 ～"></a>Demo – 先做个小测试 ～</h4><p><strong>这里先介绍个好玩的机器人api</strong></p>
<p>Robohash <a href="https://robohash.org/">https://robohash.org/</a></p>
<p>在这个网站 url 中，输入任意字符，就能帮你随机生成一个小机器人，这个想法是不是超级可爱呢！！！</p>
<p>好啦， 我们的网站就要利用到这个功能，来生成我们自己的机器人小卡片。</p>
<p>首先，在 src 文件夹里新建 Card.js 文件, 把这个网站随机生成的图片 url 放到代码里。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Card</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Card&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello, I am a Robot<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://robohash.org/irina&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;robots&quot;</span> /&gt;</span> </span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Card;<br></code></pre></td></tr></table></figure>



<p>在 index.js 中，导入 Robot.js, 并且把  <App /> 替换为 <Card /></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 新增以及替换的代码</span><br><span class="hljs-keyword">import</span> Card <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Card&#x27;</span>;<br><br>ReactDOM.render(<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.StrictMode</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Card</span> /&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">React.StrictMode</span>&gt;</span></span>,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br><br></code></pre></td></tr></table></figure>

<p>刷新下我们的本地页面，哈哈 机器人就出现和你打招呼啦🙋。</p>
<p>测试成功～</p>
<p>![image-20201114222806928](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201114222806928.png)</p>
<h4 id="机器人卡片制作"><a href="#机器人卡片制作" class="headerlink" title="机器人卡片制作"></a>机器人卡片制作</h4><p>1 首先，可以在 Card.js 中美化下卡片的 css 样式。 </p>
<p>先安装一个 依赖包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm install tachyons<br></code></pre></td></tr></table></figure>

<p>在 Card.js 中通过 className 调用它的样式～ </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;tachyons&quot;</span><br>&lt;div className=<span class="hljs-string">&quot;bg-light-green dib br3 pa3 na2 grow bw2 shadow-5&quot;</span>&gt;  <br></code></pre></td></tr></table></figure>

<p>2 然后做很多卡片：</p>
<p>因为  <Card /> 就是一个 component 了， 所以可以不断复用它。</p>
<p>直接复制就好了。</p>
<p>3 但是所有卡片里面的机器人名字和图像都是一模一样的， 我想让里面的信息是不一样的。</p>
<p>于是制作机器人对象：</p>
<p>用一个常量 robot 来存所有的机器人的信息。</p>
<p>![image-20201115022317648](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201115022317648.png)</p>
<p>在 index.js 中依次取出他们的信息 当作参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;robots&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./robots&#x27;</span>;<br>ReactDOM.render(<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.StrictMode</span>&gt;</span></span><br><span class="xml">    &#123;/* <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span> */&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Card</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&#123;robots[0].id&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;robots[0].name&#125;</span> <span class="hljs-attr">email</span> =<span class="hljs-string">&#123;robots[0].email&#125;/</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Card</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&#123;robots[1].id&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;robots[1].name&#125;</span> <span class="hljs-attr">email</span> =<span class="hljs-string">&#123;robots[1].email&#125;/</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Card</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&#123;robots[2].id&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;robots[2].name&#125;</span> <span class="hljs-attr">email</span> =<span class="hljs-string">&#123;robots[2].email&#125;/</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Card</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&#123;robots[3].id&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;robots[3].name&#125;</span> <span class="hljs-attr">email</span> =<span class="hljs-string">&#123;robots[3].email&#125;/</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Card</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&#123;robots[4].id&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;robots[4].name&#125;</span> <span class="hljs-attr">email</span> =<span class="hljs-string">&#123;robots[4].email&#125;/</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">React.StrictMode</span>&gt;</span></span>,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure>



<p>在 Card.js 中传入指定好的参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Card</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;bg-light-green&quot;</span>&gt;</span>  </span><br><span class="xml">    &#123;/* dib br3 pa3 na2 grow bw2 shadow-5*/&#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://robohash.org/irina?200*200&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;robots&quot;</span> /&gt;</span> </span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;props.email&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>哈哈，别忘了把它们的样子也改一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;img src=&#123;<span class="hljs-string">`https://robohash.org/<span class="hljs-subst">$&#123;props.id&#125;</span>?200x200`</span>&#125; alt=<span class="hljs-string">&quot;robots&quot;</span> /&gt; <br></code></pre></td></tr></table></figure>

<p>tips: 1. ⚠️注意这里要把引号改为 ` 哦！！！</p>
<p>​         2. 所有的 js expression， 比如 props.name， 都要加大括号。</p>
<ul>
<li><p>Js experssion</p>
</li>
<li><p>```javascript<br>const cardsArray = robots.map( </p>
<pre><code>    (uesr, i) =&gt; 
    &#123;return &lt;Card key=&#123;i&#125; id = &#123;robots[i].id&#125; name=&#123;robots[i].name&#125; email =&#123;robots[i].email&#125;/&gt;
&#125;)
</code></pre>
<p>// cardsArray, i 都是 Js experssion 要加大括号。<br>// 换句话说， 要想在 react 里面写 js 只要加上大括号就行了。    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>  <br><br>  酱酱！完成后就是下面👇这个样子，是不是还蛮酷的内～<br><br>  至此，我们的机器人小网站的雏形就有啦。<br><br>  ![image-20201116001159587](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201116001159587.png)<br><br><br><br>#### 实现搜索功能<br><br>*动态可变的State  --&gt; props*<br><br>*模块长这样：*<br><br>*app*<br><br>*cardList.   searchBox*<br><br>*Card*<br><br><br><br>##### 思路：<br><br>要让 searchBox 和 cardList 能通过父节点互动。<br><br>可以通过 React 中的 State 来实现：<br><br>State 的动态可以被当作props 传送到 searchBox 和 cardList 中。<br><br>这里可以设置 2 个state，一个是搜索关键词，起名为searchfield， 一个是被搜到的 robots，起名为 robots 。<br><br>​	<br><br>##### 实现：<br><br>searchBox 传一个参数 searchChange<br><br></code></pre></td></tr></table></figure>
<p>function SearchBox(searchChange) {<br>  return (</p>
   <div className="pa2">
   <input 
   className = "pa3 ba b--green bg-lightest-blue"
   type="search" placeholder="search robots"
   onChange={searchChange}/>
   </div>   
  );
}
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br><br><br>父节点 app 是传送的枢纽，用 event 来监控输入 searchBox 的文字，<br><br></code></pre></td></tr></table></figure>
class App extends Component {
{/* constructor是一个mounting方法 */}
constructor(){
  super()
  this.state = {
    robots : robots,
    searchfield: ""
  }
}

<p>// 这里一定要用箭头函数，因为这个是在Searchbox被调用的，不这样写会找不到this<br>onSearchChange = (event ) =&gt; {<br>   this.setState({ searchfield: event.target.value)   })<br>}</p>
<p>render(){<br>  const { robots, searchfield } = this.state<br>  return (</p>
<pre><code>&lt;div className=&quot;tc&quot;&gt; 
&#123;/* textcenter */&#125;
&lt;h1&gt;RoboFriends&lt;/h1&gt;
&lt; SearchBox searchChange=&#123;this.onSearchChange&#125;/&gt;
&#123;/* state 传到这变 props 作为&#123;robots&#125; 传到 CardList*/&#125;
&lt;CardList robots=&#123;robots&#125;/&gt;
&lt;/div&gt;
</code></pre>
<p>  );<br>}<br>}</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>继续改进这个传送机制，让父节点 app 传送刚刚接收到的信息到 cardList<br><br></code></pre></td></tr></table></figure>
<p> render(){<br>    const { robots, searchfield } = this.state<br>    const filteredRobots = robots.filter( robots =&gt;{<br>      return robots.name.toLowerCase().includes(searchfield.toLowerCase())<br>   })<br>    return (<br>      <div className="tc"><br>      {/* textcenter <em>/}<br>      <h1>RoboFriends</h1><br>      &lt; SearchBox searchChange={this.onSearchChange}/&gt;<br>      {/</em> state 传到这变 props 作为{robots} 传到 CardList*/}<br>      <CardList robots={filteredRobots}/><br>      </div><br>    );<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br><br><br>##### 新增功能：下拉的时候搜索框也悬浮在顶端<br><br>Index.js<br><br></code></pre></td></tr></table></figure>
<scroll>

<p> {*/ scroll 内部的内容就是它的chirldren */}<br> <CardList robots={filteredRobots}/></p>
</scroll>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>Scroll.js<br><br></code></pre></td></tr></table></figure>
<p>function Scroll( props ) {<br>    return (</p>
<pre><code> &lt;div style =&#123; &#123;overflowY:&quot;scroll&quot;, border: &quot;1px solid black&quot;, height: &quot;500px&quot;&#125;   &#125;&gt;
    &#123;props.children&#125;
 &lt;/div&gt;
)
</code></pre>
<p>  };</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br><br><br>#### 最后再美化下整个网站<br><br>##### 网站背景<br><br>Index.css<br><br></code></pre></td></tr></table></figure>
<p>body {<br>  margin: 0;<br>  padding: 0;<br>  font-family: sans-serif;<br>  background: linear-gradient(to left, rgba(7, 27, 82, 1) 8%, rgba(8, 128, 128, 1) 100%);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br><br><br>##### 字体<br><br>Google 搜索自己想要的酷酷的字体。<br><br>下载它的 @font face (web) 版本，<br><br> 把他的css  复制到 app.css中，woff 文件则拖到我们的 src 文件夹中 。<br><br><br><br>![image-20201116165810190](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201116165810190.png)<br><br><br><br><br><br>### 动态请求<br><br>如果要在现实世界中运行我们的网站，这些机器人的信息不应该直接写在我们网站中的。<br><br>而是由真实的用户填写，浏览器发出请求而被我们所接收和响应。<br><br><br><br>现在我们可以用一个免费的API接口一个网站叫做 https://jsonplaceholder.typicode.com/<br><br>把我们的用户数据放在这个网站上，有我们来抓取模拟浏览器请求。<br><br><br><br></code></pre></td></tr></table></figure>
<p>  // 1. 把robot.js 信息删掉， 导入文件的语句也要删掉<br>  // 2. state 中接受的robot 设为空<br>  // 3. 通过 fetch url 来得到数据<br>  constructor(){<br>    super()<br>    this.state = {<br>      robots : [],<br>      searchfield: “”<br>    }}</p>
<p>  componentDidMount(){<br>    fetch(“<a href="https://jsonplaceholder.typicode.com/users&quot;">https://jsonplaceholder.typicode.com/users&quot;</a>)<br>      .then(response =&gt;{ response.json()<br>      .then(users =&gt; this.setState({ robots:users}));<br>      })<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br><br><br>在获取 url 数据的等待时间，页面什么也不返回。<br><br>如果数据量大，查找时间很长的话，会让用户很困惑。<br><br>所以在未获取数据的时候，可以提示正在加载 “Loading” 中。<br><br></code></pre></td></tr></table></figure>
<p>render(){<br>    const filteredRobots = this.state.robots.filter( robots =&gt;{<br>      return robots.name.toLowerCase().includes(this.state.searchfield.toLowerCase())<br>   })<br>   if (this.state.robots.length === 0){<br>     return <h1>Loading</h1><br>   } else{<br>    return (<br>      <div className="tc"><br>      {/* textcenter <em>/}<br>      <h1 className="f1">RoboFriends</h1><br>      &lt; SearchBox searchChange={this.onSearchChange}/&gt;<br>      {/</em> state 传到这变 props 作为{robots} 传到 CardList*/}<br>      <CardList robots={filteredRobots}/><br>      </div><br>    );<br>   }<br>  }</p>
<pre><code>


### 可以发布啦！！

step 1. npm run-script build

react 会帮自动打包出一个可被用于生产环境的最优文件夹 build。

![image-20201116174504858](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201116174504858.png)

step 2. 把他们放到 HTTP 服务器 或者 github 中。

比如 tomcat 或者 github page。

（这个还可以单开个教程，如果大家感兴趣的话可能后续也会写写233）







## ps. 

### 关于 create-react-app

本教程使用的是截止 2020.11.15 create-react-app 的最新版本。

如果是以前装了旧版本的宝宝想要更新：

1 在 package.json 中把 react-scripts 版本改到最新 或者和我一样的“4.0.0”。

2 在终端 npm install

就更新好了。

对新版本感兴趣的宝宝还可以去官网看看。

![image-20201114171737074](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201114171737074.png)



### 
</code></pre>
]]></content>
      <tags>
        <tag>fontend</tag>
      </tags>
  </entry>
  <entry>
    <title>Growth Hacking -- Linkedin 篇</title>
    <url>/hexo-blog/2021/01/06/title-%20Growth%20Hacking%20--%20linkedin%20%E7%AF%87/</url>
    <content><![CDATA[<h1 id="lt-Title-gt"><a href="#lt-Title-gt" class="headerlink" title="&lt;#Title#&gt;"></a>&lt;#Title#&gt;</h1><p>应该在那场酒会上互fo大家的 linkedin 的<br>不过 我现在可以完善自己的主页后，在群里让大家互相关注。</p>
]]></content>
      <tags>
        <tag>growth hacking</tag>
      </tags>
  </entry>
  <entry>
    <title>文章一键发布脚本操作</title>
    <url>/hexo-blog/2020/12/09/%E4%B8%80%E9%94%AE%E5%8F%91%E5%B8%83%E8%84%9A%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><strong>写在前面： 知乎用工具发文会被封号！</strong></p>
<p>文章一键发布工具： <a href="https://openwrite.cn/">https://openwrite.cn/</a> 和 ArtiPub </p>
<p>但是考虑到有封号的风险，并且仅仅是批量发布文章，失去了平台社区的互动，感觉没有灵魂。<br>所以我最后放弃了两者，选择了部分平台手动发布文章。</p>
<p>如果你不担心封号，也只是用来发布文章，那么有部署服务能力的推荐使用ArtiPub，没能力或者不想自己部署的就使用 OpenWrite。</p>
<p>bloghelper</p>
<pre><code>npm install
npm install electron --verbose
(with --verbose it makes it much more obvious if you&#39;re somehow interrupting the electron module download during node_modules install)
You can also download the ZIP file manually in your browser from here and place it in your C:\Users\&lt;username&gt;\.electron folder. Then it won&#39;t need to download itself 👍
</code></pre>
<p>这个是 win系统下的。mac用会有很多问题：<a href="https://zhuanlan.zhihu.com/p/44741972">https://zhuanlan.zhihu.com/p/44741972</a></p>
]]></content>
      <tags>
        <tag>Script</tag>
      </tags>
  </entry>
  <entry>
    <title>自己造轮子</title>
    <url>/hexo-blog/2020/12/23/%E4%B8%8B%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%A2%98%20-%20%E8%87%AA%E5%B7%B1%E9%80%A0%E8%AE%BA%E5%AD%90/</url>
    <content><![CDATA[<p>下一个主题</p>
<p>自己造轮子</p>
<p>开发一个组件或库，被人引用。</p>
<p>操作系统内核<br><a href="https://github.com/woai3c/MIT6.828">https://github.com/woai3c/MIT6.828</a></p>
]]></content>
  </entry>
  <entry>
    <title>再也不用担心我搞不懂高并发啦</title>
    <url>/hexo-blog/2020/02/19/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E7%94%A8%E6%8B%85%E5%BF%83%E6%88%91%E6%90%9E%E4%B8%8D%E6%87%82%E9%AB%98%E5%B9%B6%E5%8F%91%E5%95%A6/</url>
    <content><![CDATA[<p><strong>高并发</strong></p>
<p>线程安全：</p>
<p>what：</p>
<p>不安全的案例：</p>
<p>ArrayList、Set、Hashmap（jdk1.8后，put操作：线程A会把线程B插入的数据给<strong>覆盖</strong>，发生线程不安全。）</p>
<p>Solutions:</p>
<p>1 不放到公共领域</p>
<p>2 每次用复制一份 juc. Cow  CopyOnwriteArrayList/Set 去官方文档上看，还有很多很多。</p>
<p>3 只能看不能改 final</p>
<p>4 锁🔒  4.1 synchonized 锁（自动挡）；8锁规则理解原理  4.1 进阶 lock （手动挡）</p>
<p>5 CAS 乐观锁 </p>
<p>===</p>
<p>相关知识：</p>
<p>数据库的并发怎么解决。</p>
<p>数据库ACID</p>
<p>其中，隔离机制有_种:</p>
<p>可重复读：</p>
<p>不可重复读：：</p>
<p>资料： </p>
<p>10年程序员深入浅出讲线程： <a href="https://www.cnblogs.com/lixinjie/p/base-knowledge-about-java-multi-thread.html">https://www.cnblogs.com/lixinjie/p/base-knowledge-about-java-multi-thread.html</a></p>
]]></content>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么写好技术文章 -- 知乎live</title>
    <url>/hexo-blog/2020/12/09/%E6%80%8E%E4%B9%88%E5%86%99%E5%A5%BD%E7%9F%A5%E4%B9%8E%E6%96%87%E7%AB%A0--%E7%9F%A5%E4%B9%8Elive/</url>
    <content><![CDATA[<h1 id="技术文章-问答部分还没看完～干货满满"><a href="#技术文章-问答部分还没看完～干货满满" class="headerlink" title="技术文章 - 问答部分还没看完～干货满满"></a>技术文章 - 问答部分还没看完～干货满满</h1><p>有满满套路</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="阐述问题-解决问题"><a href="#阐述问题-解决问题" class="headerlink" title="阐述问题 解决问题"></a>阐述问题 解决问题</h3><h3 id="翻译类"><a href="#翻译类" class="headerlink" title="翻译类"></a>翻译类</h3><h3 id="系列教程"><a href="#系列教程" class="headerlink" title="系列教程"></a>系列教程</h3><h2 id="怎么算好"><a href="#怎么算好" class="headerlink" title="怎么算好"></a>怎么算好</h2><h3 id="内容-能读懂"><a href="#内容-能读懂" class="headerlink" title="内容-能读懂"></a>内容-能读懂</h3><h4 id="抓住问题本质，做出最精准定义。"><a href="#抓住问题本质，做出最精准定义。" class="headerlink" title="抓住问题本质，做出最精准定义。"></a>抓住问题本质，做出最精准定义。</h4><p>任何复杂事情其实是简单事情错综复杂交织在一起组成的。 因此想要搞懂问题要先学会拆分。</p>
<p>拆分前要先去除无关紧要的东西</p>
<p>理解背景知识</p>
<ul>
<li>具体分析 （如，看源码）</li>
<li>抽象总结 （归纳）</li>
</ul>
<p>尽量能考虑到对方的理解水平，不要用术语，或者准备背景知识。</p>
<p>联系现实生活中的映射</p>
<p>借鉴高质量英文文章或者大牛文章去理解问题</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="思路-⭐️"><a href="#思路-⭐️" class="headerlink" title="思路 ⭐️"></a>思路 ⭐️</h3><p><strong>引言</strong></p>
<p><strong>先给个定义告诉读者你在写什么技术。还要给出为啥要被创造出来和目的。</strong></p>
<p><strong>然后介绍怎么使用。实现原理，运行原理</strong></p>
<p><strong>技术的弊端和不足。</strong></p>
<p><strong>注意事项、自己遇到的坑。</strong></p>
<p><strong>总结</strong></p>
<p>注意过渡。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>使用方法，实现原理，运行原理详细写。</p>
<p>注意事项 或者一些定义 可以粗略写。</p>
<h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><p>文字主要以小段落小段落 因为现代人看到大块的文字会有些抵触</p>
<p>层级 html heading h1- h6</p>
<p>强调内容 加粗</p>
<p>编程中的方法名 路径突出</p>
<p>代码高亮！！！！</p>
<p>不建议过长，尤其要避免横向过长导致的水平滚动线。</p>
<p>可以通过拆分 或者 换行 解决。</p>
<h2 id="怎么确定主题"><a href="#怎么确定主题" class="headerlink" title="怎么确定主题"></a>怎么确定主题</h2><p>选题很重要！ 会影响阅读量。</p>
<p>授人以渔 或 受人以渔</p>
<h3 id="1-读者需求导向"><a href="#1-读者需求导向" class="headerlink" title="1.读者需求导向"></a>1.读者需求导向</h3><p>新的技术， 热门技术。技术系列专题。鸡汤类大家都爱读。</p>
<h3 id="2-个人研究为导向"><a href="#2-个人研究为导向" class="headerlink" title="2.个人研究为导向"></a>2.个人研究为导向</h3><p>技术细节。编程基础。通过文章提升自己水平，完善自己技术体系。</p>
<h2 id="套路-撰写的阶段"><a href="#套路-撰写的阶段" class="headerlink" title="套路-撰写的阶段"></a>套路-撰写的阶段</h2><p>1 研究阶段 （碎片化时间）</p>
<p>将某项技术<strong>拆分</strong>成点。（比如见思路篇）</p>
<p>用零碎时间去研究这些点。</p>
<p>2 书写阶段 （连续时间）</p>
<p>图文输出。</p>
<h2 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h2><p>现成的。</p>
<p>自己搭的。（作者就是自己搭的静态网站）</p>
<p>推荐 hexo， 原则是支持markdown的 （嘿嘿）</p>
<p>前期流量会特别小，像个孤岛。</p>
<p>不过长期就还好。</p>
<h2 id="更新频率"><a href="#更新频率" class="headerlink" title="更新频率"></a>更新频率</h2><p>不一定。</p>
<p>可以每周更新。</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><p>写作风格</p>
<p>Q：文章怎么吸引人 ？</p>
<p>A：可以选流行的主题，不过不建议太标题党。</p>
<p>Q：从无到有的介绍还是直接讲要害 ？</p>
<p>A：大而全的文章 不如 小而精的文章。</p>
<p>Q：一定需要规规矩矩写吗，写成感悟式样的行吗 ？</p>
<p>A：只要能清楚的讲清楚事情，让读者能够明白问题就行。</p>
<p>Q：读书笔记类文章，怎么写才能不和原书重合 ？</p>
<p>A：文化背景不同，可以把栗子替换成周围人更贴近的例子。</p>
<p>提取文章的重点。</p>
<p>写作提升在积累中思考</p>
<p>Q：技术文章写的像文档，怎么办 ？</p>
<p>A：可以对文章结构进行细分。行文中做好承上启下的过渡。</p>
<p>Q： 为啥看的很多，仍然写不好 ？</p>
<p>A：看是不够的，还要思考、咀嚼、写。</p>
<p>Q：平时怎么积累 ？</p>
<p>A：多思考。多提一些问题。解决这个问题当前方法有什么优缺点，有什么更好的方法吗。</p>
<p>理解一些<strong>运行和实现原理</strong>，而不仅仅是使用。多看，不懂的地方可以记录下来。</p>
<p>Q：怎么解决一个问题 ？</p>
<p>A：最重要的是确定问题的本质。然后通过debug 或者 关键日志 去了解过程。 在然后遇到问题去搜索。</p>
<p>Q：表达复杂技术知识有啥技巧 ？</p>
<p>A: 自己去把这个复杂事情弄明白。然后举通俗易懂的例子。</p>
<p>学会利用社会曝光 - 写作小组</p>
<p>Q：写完后如何与读者达成良好的沟通 ？</p>
<p>A：能明明白白讲给别人，别人能听懂。</p>
<p>发布前：建立文章 review 小组，与小组人员交流。</p>
<p>发布后：开启评论功能，能让读者留言。</p>
<p>Q：怎么防止写着写着跑题 ？</p>
<p>A：写之前可以列提纲。每个板块写完后可以进行检查。全文写完再检查。过几天可以再看 或者找别人来看。</p>
<p>Q: 怎么坚持啊 ？</p>
<p>A：可以发朋友圈。</p>
<p>时间规划 - 要学会拆分结构</p>
<p>Q：怎么解决与工作时间的冲突 ？</p>
<p>A：对文章切分。研究阶段利用好碎片时间，写作阶段周末。</p>
<p>Q： 是先学还是先写文章 ？</p>
<p>A：这是一个悖论。 就像先产出还是先涨工资。</p>
<p>其实可以先写，比如理解了 60% 的程度， 在写的过程中就说不定掌握了剩下的 40%。</p>
<p>原创</p>
<p>Q：哪些要标原创和转载 ？</p>
<p>A：翻译的话要标出原作者并且获得授权。如果参考了别人的文章，需要把链接写出来。</p>
]]></content>
      <tags>
        <tag>Writing</tag>
      </tags>
  </entry>
  <entry>
    <title>【教程】Mac 怎么启动第一个 SpringBoot项目</title>
    <url>/hexo-blog/2021/01/22/%E6%80%8E%E4%B9%88%E5%90%AF%E5%8A%A8%E7%AC%AC%E4%B8%80%E4%B8%AA%20SpringBoot%20%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h3 id="背景知识："><a href="#背景知识：" class="headerlink" title="背景知识："></a>背景知识：</h3><h3 id="Spring-Maven-SpringBoot"><a href="#Spring-Maven-SpringBoot" class="headerlink" title="Spring -Maven - SpringBoot"></a>Spring -Maven - SpringBoot</h3><p>一句话简单讲述三者关系： “ The quickest way to create a Spring application is to use a <a href="https://spring.io/projects/spring-boot">Spring Boot</a> Maven project.”</p>
<p>— 官方教程指路： <a href="https://www.jetbrains.com/help/idea/2020.3/your-first-spring-application.html">https://www.jetbrains.com/help/idea/2020.3/your-first-spring-application.html</a></p>
<h4 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h4><p>What：包管理器</p>
<p><strong>tips: maven 配置里面有个奇天大坑</strong>，不是为了下载依赖快一点改成国内的镜像了吗，结果老是出错也不知道是为啥。</p>
<p>折腾好几天才想起来，我一直是翻着墙的。。。 干啥子要用国外的站点下国内的资源嘛！ 要么改回原来镜像，要么关掉梯子。</p>
<p>果然，</p>
<p>变得又快又好了。</p>
<p>【第一次打开一个项目的时候，要下很多依赖会有点慢。但是之后打开就很快了。】</p>
<h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h4><p>What: 万能框架</p>
<p>官方文档（<a href="https://spring.io/projects/spring-boot%EF%BC%89">https://spring.io/projects/spring-boot）</a></p>
<p><strong>原则：约定大于配置</strong></p>
<p>比如：</p>
<p>文件摆放位置；</p>
<p>application.yaml (必须是这个名字) 配置可以放在一下位置，<br>执行优先级依次是：<br>项目路径./ config文件夹/application.yaml<br>项目路径./application.yaml<br>classpath :/config文件夹/application.yaml<br>classpath :/application.yaml</p>
<p>场外提示： classpath =类路径=src-main-java/resource 下面都算</p>
<h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>IDEA – spring initializr</p>
<h3 id="三种启动方法"><a href="#三种启动方法" class="headerlink" title="三种启动方法"></a>三种启动方法</h3><p><strong>在这三种启动方法前，如果你同时导入的是多个项目，并且maven没有出现的话。需找到每个项目的pom.xml，右键，add as a maven project.</strong></p>
<p><a href="https://blog.csdn.net/weixin_34296641/article/details/94171666?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control">https://blog.csdn.net/weixin_34296641/article/details/94171666?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control</a><br>前两种方法供本地运行，第三种是线上部署使用<br><strong>方法1: 直接点绿色箭头运行</strong></p>
<p>最关键就是要先 mvn package， 再点运行</p>
<p><strong>方法2</strong>: 应用的根目录下运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">mvn -U clean spring-boot:run<br></code></pre></td></tr></table></figure>

<p>(没有自动创建也可以用这个手动创建)</p>
<p><strong>方法3: 使用mvn install 生成jar后运行</strong><br>先到项目根目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">mvn compile<br>mvn package<br>java -jar target/xxx.jar<br>https://spring.io/guides/gs/maven/#initial<br></code></pre></td></tr></table></figure>



<p><strong>1 mvn  clean install</strong><br>在有的pom路径下<br>mvn  clean install<br>（This will clean whatever created from the previous build, then build your project and add the jars to your local maven repository ）<br>就会帮忙安装pom里的依赖</p>
<p>Maven projects are defined with an XML file named <em>pom.xml</em>. Among other things, this file gives the project’s name, version, and dependencies that it has on external libraries.</p>
<p><strong>2 cd target</strong><br><strong>3 java -jar   xxxx.jar</strong><br>tips: 使用maven工具打包（jar包），打包时要注意，由于模块与模块之间的依赖关系，所以打包是要有顺序的，需要先打被依赖的模块；你也可以在父类模块上打一个包。</p>
<p>其他配置 (可选)<br>perference – maven -importing -勾选 自动下载 sources</p>
<h3 id="启动别人的项目"><a href="#启动别人的项目" class="headerlink" title="启动别人的项目"></a>启动别人的项目</h3><p><a href="https://blog.csdn.net/gao_xiao_qi/article/details/99707592">https://blog.csdn.net/gao_xiao_qi/article/details/99707592</a><br><a href="https://www.pianshen.com/article/16541114992/">https://www.pianshen.com/article/16541114992/</a><br>要<strong>import</strong> 而不是 open：<br>file-new-from existing project-maven</p>
<p><strong>配置：</strong><br><strong>Crtl+Alt+s 快捷键打开idea设置，并搜索maven。</strong></p>
<p><strong>里面的setting 还有仓库要改成自己的位置啊！</strong></p>
<p><strong>贴心避坑指南总结：</strong></p>
<p>1.找不到classpath下的resources ：</p>
<p>首先，需要把 java 文件夹右键 - 标成蓝色，resources - 标成绿色。 （或者在 file – project structure 改动）</p>
<p>其次，每个pom.xml 都要右键 - <strong>add as a maven project.</strong> 不过要是右键没有的话也不用担心，这说明已经是maven项目了。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn2eza21efj30ad0gzq4v.jpg"></p>
<p>2  启动顺序很重要 ！！！！！</p>
<p>如果一个项目中，有多个子项目，那么要注意启动顺序。</p>
<p>因为有的项目的依赖需要在其他项目编译完之后才能拥有。</p>
<p>一般启动顺序如下：</p>
<p>1注册中心eureka  2网关 gateway</p>
<p>3配置中心config   4 api  5服务中心 user</p>
<p>依次启动 round-table-eureka-server 、round-table-config-server、round-table-user-server</p>
<p>![image-20210119235350856](/Users/lujiawen/Library/Application Support/typora-user-images/image-20210119235350856.png)</p>
<p>3 现在和大家提醒一个很大的坑。我这次所有的子项目都有一个父项目spring-boot-starter-parent。</p>
<p>明明pom中导入了依赖，本地也有这个包，但是为什么会提示找不到呢。</p>
<p>注意：仔细看下pom中，包的地址是相对路径！！！！</p>
<p>不懂 relativePath 指的是哪个仓库的话，在idea中点击进去看源码。</p>
<p>可知：它的默认值是…/pom/xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;parent&gt;<br>   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>   &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;<br>   &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;<br>   &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;<br>&lt;/parent&gt;<br></code></pre></td></tr></table></figure>

<p>在resources下面新建lib文件夹，并把jar包文件放到这个目录下 .${project.basedir}只是一个系统自己的常量</p>
<p><systemPath>${project.basedir}/src/main/resources/lib/alicom-mns-receive-sdk-1.0.0.jar</systemPath>  </p>
<p><strong>4 导包失败：</strong></p>
<p>有了maven后 导包快捷键： alt+回车，</p>
<p>如果本地仓库没有的话，去maven repository 上搜索，然后在pom.xml中引用。</p>
<p><a href="https://wangao.info/2020/04/13/spring-boot-00/">https://wangao.info/2020/04/13/spring-boot-00/</a></p>
<p>5 <strong>找不到主类</strong>/没有主清单属性</p>
<p><a href="https://www.cnblogs.com/thinking-better/p/7827368.html">https://www.cnblogs.com/thinking-better/p/7827368.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;!--自动生成主清单属性--&gt;<br>    &lt;build&gt;<br>    &lt;plugins&gt;<br>    &lt;plugin&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;<br>        &lt;configuration&gt;<br>           &lt;!--设置自己想要的主类--&gt;<br>            &lt;mainClass&gt;com.jj.api.rest.common.MapToolUtil&lt;/mainClass&gt;<br>        &lt;/configuration&gt;<br>    &lt;/plugin&gt;<br>    &lt;/plugins&gt;<br>    &lt;/build&gt;<br></code></pre></td></tr></table></figure>



<p>6 user子程序启动问题</p>
<p><strong>Could not locate PropertySource: I/O error on GET request</strong></p>
<p>在usr -dev -   .xml中 关闭 spring.cloud.config 的配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">spring.cloud.config= false<br></code></pre></td></tr></table></figure>



<p>7 找不到符号</p>
<p>把.idea删除，再重新打开ide</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;plugin&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;<br>&lt;/plugin&gt;<br><br>所以我就把他注释了再编译，结果就没问题了，所以我觉得应该是这个插件导致<br></code></pre></td></tr></table></figure>



<p>8 plugins 报红色波浪线</p>
<ul>
<li>到本地仓库下找到未下载成功的插件及对应版本</li>
<li>删掉后缀为<code>lastUpdated</code>的文件</li>
<li>再到idea上 maven刷新按钮重新下载即可成功</li>
</ul>
<p>9 程序包不存在-导入maven项目时程序包不存在</p>
<p>出错原因：project structure – Libraries – 第三栏 sources, javaDocs 包 没找到或者安装错误。</p>
<p>去仓库找到相对应版本的包安装位置，<strong>如果文件是以 .lastUpdated 结尾的，那这就是下载失败的jar，当这个下载失败的文件存在的时候，reimport 我们的pom.xml文件，它是不会重新下载这个失败的jar的。</strong></p>
<p>解决方案： </p>
<p>Step 1: 重新导入前的准备。</p>
<p>首先尝试了以下几种方式，但是没能解决问题（注意是无效的）：**</p>
<ul>
<li>修改maven的 <code>settings.xml</code> 增加或修改<code>mirror</code>或其他配置（并非中央仓库问题）；</li>
<li>删除<code>.lastUpdated</code>文件 (删除后会复活);</li>
</ul>
<ul>
<li><p>通过<strong>在项目路径下使用<code>mvn -U compile</code>命令！</strong></p>
</li>
<li><p>在maven 的settings里面加入：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;profiles&gt;<br>&lt;profile&gt;<br>    &lt;id&gt;downloadSources&lt;/id&gt;<br>    &lt;properties&gt;<br>        &lt;downloadSources&gt;true&lt;/downloadSources&gt;<br>        &lt;downloadJavadocs&gt;true&lt;/downloadJavadocs&gt;           <br>    &lt;/properties&gt;<br>&lt;/profile&gt;<br>&lt;/profiles&gt;<br><br>&lt;activeProfiles&gt;<br>  &lt;activeProfile&gt;downloadSources&lt;/activeProfile&gt;<br>&lt;/activeProfiles&gt;<br></code></pre></td></tr></table></figure>

<p>Step 2: 重新导入</p>
<p>Step 3: 点第三列左上角+号，选择并添加正确的lib文件路径。</p>
<ul>
<li>/Users/lujiawen/Desktop/工作台/my_packs_env_dont_change_name_position/apache-maven-3.6.3/repository/antlr/antlr/2.7.7/antlr-2.7.7-sources.jar</li>
</ul>
<p>未解决</p>
<p>10 java.lang.IllegalStateException: Service id not legal hostname (${feign.serviceId.user})</p>
<p>user 中 resources 文件夹下 取名为 application.yml 的配置文件， 最好不要随便改名。</p>
<p>11 Could not autowire. No beans of ‘xxxx’ type found</p>
<p>（这个错误提示并不会产生影响。控制台也不报错，可以正常运行。）</p>
<p>。如果有强迫症的童鞋可以尝试：</p>
<p>1降低Autowired检测的级别，将Severity的级别由之前的error改成warning或其它可以忽略的级别。</p>
<p>2确认导包是否正确：import org.springframework.stereotype.Service;</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpv14blw2j31010o50xl.jpg"></p>
<p>参考资料：</p>
<p><a href="https://blog.csdn.net/sunnyzyq/article/details/86711708">https://blog.csdn.net/sunnyzyq/article/details/86711708</a> ⭐️</p>
<p>自己创建：<a href="https://blog.csdn.net/typa01_kk/article/details/76696618">https://blog.csdn.net/typa01_kk/article/details/76696618</a></p>
<p>配置gitlab： <a href="https://blog.csdn.net/u010454030/article/details/80653660">https://blog.csdn.net/u010454030/article/details/80653660</a></p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>我是怎么让我的网站变得国际化的</title>
    <url>/hexo-blog/2021/02/07/%E6%88%91%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%A9%E6%88%91%E7%9A%84%E7%BD%91%E7%AB%99%E5%8F%98%E5%BE%97%E5%9B%BD%E9%99%85%E5%8C%96%E7%9A%84/</url>
    <content><![CDATA[<p>资料： <a href="https://tstrs.me/1448.html">https://tstrs.me/1448.html</a> ⭐️</p>
<p><a href="https://juejin.cn/post/6844904155073478670">https://juejin.cn/post/6844904155073478670</a></p>
<p>一个可爱的slackbot <a href="https://tstrs.me/1431.html#">https://tstrs.me/1431.html#</a></p>
]]></content>
  </entry>
  <entry>
    <title>由操作系统衍生开的学习心法</title>
    <url>/hexo-blog/2021/01/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20--%20%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%A6%E4%B9%A0%E5%BF%83%E6%B3%95/</url>
    <content><![CDATA[<p>操作系统得要对电脑硬件有个直观的认识，学起来会事半功倍</p>
<p>这类感觉，这种概念信息，积累的越多，解决问题的能力越强，脑子越好使。</p>
<p>「随机把你丢到你们家附近的哪个地方，你看一眼就知道家在哪儿了，就能走回去。这无法用语言表达，如果是别人去你家，你得先确认他位置，然后给他描述各种标志，各种路口，到哪儿怎么走。无论你用多少词汇，说多少话，怎么形容，这在他脑海里都是一篇朦胧。语言传达不了，只有他自己走一遍才明白。</p>
<p>学习里面就是充满了这些语言根本无法传达的东西。这些东西，才是无比重要，才是你用来解决问题的东西。光会背没有用，要去使用，使用以后，用来解决问题以后，才会对这个东西到底怎么用，有个深刻的印象。就像你遇到个老外，什么都不解释，教他说“你好”，教完你走了，他还是不懂这两个字怎么用。名是不重要的东西，重要的是它背后的概念、给人的感觉。名只是指代概念的一个引子，不要本末倒置。<a href="https://zhuanlan.zhihu.com/p/341504747%E3%80%8D">https://zhuanlan.zhihu.com/p/341504747」</a></p>
<p>（以下适合放到evernote？）</p>
<p>leetcode 学习心法</p>
<p>「所以，理科的问题，努力钻研的过程必不可少，哪怕你穷尽各种想法，解决不了问题，也最好是先钻研过了再看答案。有时候也别以为，理解了一个理论你就会了，其实缺少了上面讲过的，把手数一遍，把它转化成5这个概念的过程，有这个过程，你才能明白，这个理论在解决问题的时候的形式是什么样的。等于说，拿对应规律来说，解决问题的时候的记忆，对应的也是解决问题时候的感觉、回忆，而不是书本上看过一遍但没用过的东西。简单的题目，可以用看过一遍的信息解决，复杂一点的，你就压根想不起来。<a href="https://zhuanlan.zhihu.com/p/341504747%E3%80%8D">https://zhuanlan.zhihu.com/p/341504747」</a></p>
<p>解决问题的能力：</p>
<p>「要注意的地方：1.没有什么生下来就有的能力，都要一步一步积累。如果你解决问题的能力强，平常的作业题目什么的都很简单，也不要对自己太松懈，不要什么都去看答案。我就犯过这种错，当我觉得数学题都太简单了之后，就懒得做了，经常直接抄答案拉倒。我以为我太聪明了，将来也不会有什么题目难倒我，于是后来我就变菜了，严重的时候菜到怀疑自己到底是不是自己，到底是怎么回事，哪儿不对，怎么居然有别人能做出来，而我不会的题目。后来对这种情形麻木了，甚至把原因归结到其它因素上，责怪教材之类的莫名其妙的东西，用那些来安慰自己，一时就是不明白真正的原因是什么。总之就是，永远不要盲目自大。别以为你有天赋。我甚至想回到小时候重新体验一遍认知过程，然后把它的变化过程细致的描述出来，好让人们明白，天赋智商还有各种“力”这种摸不着边的概念都是人们创造出来的糟粕，所有的想法行为，明明都有据可依，都能找到具体的蛛丝马迹，凭什么全都归咎于这些莫须有的概念。只是现在我凭空放出这种话，要被当成神经病的。人们习惯了拿天赋来论证问题，拿各种莫须有的东西当事实依据。但我从来不会，所以我讲的东西，很多都是生活中能切实用上的。</p>
<p>我上面说那么多，你必须明白，<strong>增强解决问题能力的最好的方式，是去解决问题，去苦心钻研，哪个点缺补哪里。</strong>这很符合对应原理。去网上查怎样增强智商，根本就是治病不治根的歪路子，你只能学会一堆词汇去描述什么是大家定义的聪明，聪明人一般都怎么样怎么样，你真正想要提升的能力，是一点都没提升。去喝鸡汤那点能量，除了学会一些振奋人心的话，你解决问题的能力也一丁点都没提升。但是现实的发展是怎样呢，你会逐渐觉得自己不聪明，自己干不出来莫名的聪明人能做的事儿，看完鸡汤觉得自己行了，然而还是不行，就开始自我怀疑、失落」</p>
]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库的那些事儿</title>
    <url>/hexo-blog/2021/01/28/%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
    <content><![CDATA[<p>pojo 实体类</p>
<p>mapper。xml有问题: <result column="dictdetail" jdbcType="VARCHAR" property="dictDetail" /> </p>
<p>Q：Dict_id 自动顺序增长，而不是自己设的值。</p>
<p>A：</p>
<p>为啥发出请求加东西，实际却没有加到数据库呢？因为我adddic 函数还没写昂。</p>
<p>接下来，做<strong>删除功能。</strong></p>
<p>遇到过的错误 Q &amp; A：</p>
<p>There is no getter for property named ‘dict_uuid’ in ‘class com.jj.red.packet.user.mybatis.domain.RoundDict’</p>
<p> There is no getter for property named ‘dict_key’ in ‘class com.jj.red.packet.user.mybatis.domain.RoundDict’</p>
<p> DEBUG [com.jj.red.packet.user.mybatis.persistence.RoundDictMapper.insertSelective] - ==&gt;  Preparing: insert into t_round_dict ( dictUuid, dictKey, dictDetail ) values ( ?, ?, ? ) </p>
<p>Q:<strong>增和删，mapper都返回1，能改吗？</strong></p>
<p> <strong>[com.jj.red.packet.user.mybatis.persistence.RoundDictMapper.insert] - &lt;==    Updates: 1</strong></p>
<p>A: resultType：适合使用返回值的数据类型是非自定义的，即jdk的提供的类型 –&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;select id=&quot;selectPersonCount&quot; resultType=&quot;java.lang.Integer&quot;&gt;<br></code></pre></td></tr></table></figure>

<p>Q: list 为啥没有返回items；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;select id=&quot;selectAll&quot; parameterType=&quot;com.jj.red.packet.user.mybatis.domain.RoundDictExample&quot; resultMap=&quot;BaseResultMap&quot;&gt;<br> <br> RoundDictExample example<br></code></pre></td></tr></table></figure>



<p>验证dict_id不能为null，不然抛出异常</p>
<p>java.lang.RuntimeException: Value for dict_id cannot be null<br>        at com.jj.red.packet.user.mybatis.domain.RoundDictExample$GeneratedCriteria.addCriterion(RoundDictExample.java:95)<br>        at com.jj.red.packet.user.mybatis.domain.RoundDictExample$GeneratedCriteria.andDictIdEqualTo(RoundDictExample.java:118)<br>        at com.jj.red.packet.user.mybatis.domain.RoundDictExample$Criteria.andDictIdEqualTo(RoundDictExample.java:763)<br>        at com.jj.red.packet.user.service.impl.RoundDictServiceImpl.getDicts(RoundDictServiceImpl.java:55)</p>
<p>Q：Unknown column ‘xxx’ in ‘field list’</p>
<p>A：数据表中字段与实体类中声明的字段对象没有用注解连接。</p>
<p>或者 将两个名字改成一致的</p>
<p>Q：不知道哪个是对应数据库的键，哪个对应实体类的键</p>
<p><em>A： <!-- 普通的列  -column 是数据库中字段， property是实体类中字段--></em>      </p>
  <result column="token" property="token" jdbcType="VARCHAR" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;!--  ADD --&gt;<br>  &lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.jj.red.packet.user.mybatis.domain.RoundDict&quot;&gt;<br>    &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;<br>      SELECT LAST_INSERT_ID()<br>    &lt;/selectKey&gt;<br>    insert into t_round_dict<br>    &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;<br>      &lt;if test=&quot;dictId != null&quot;&gt;<br>        dictId,<br>      &lt;/if&gt;<br>    &lt;/trim&gt;<br>    &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;<br>      &lt;if test=&quot;dictId != null&quot;&gt;<br>        #&#123;dictId,jdbcType=VARCHAR&#125;,    <br> &lt;!--  取值方式1：#&#123;value jdbcType = valuetype&#125;：jdbcType 表示该属性的数据类型在数据库中对应的类型，如 #&#123;user jdbcType=varchar&#125; 等价于 String username；--&gt;<br>      &lt;/if&gt;<br>    &lt;/trim&gt;<br>  &lt;/insert&gt;<br></code></pre></td></tr></table></figure>



<p>tips；UUID ： VARCHAR(36)<em>类型</em></p>
<p>终端打印出来的顺序；</p>
<p>ApplicationContext  –&gt; ContextLoader –&gt; ServletREgistrationBean –&gt; dispatcherServlet –&gt; RequestMappingHandlerMapping –&gt; Mapped (/m/add method=[POST]) to. ResponseMessage –&gt; xxController.add ; url path [/v2/api] to SwaggerController.getDocument –&gt; … —&gt; tomcat started on port xxx</p>
<p>LIST</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Controller:<br>Page&lt;RoundDict&gt; roundDicts = roundDictService.getDicts(roundDictRequest.getDictId(),roundDictRequest.getDictUuid());<br></code></pre></td></tr></table></figure>

<p>Controller:  roundDictService .getDicts –&gt; roundDictServiceImpl .getDicts( roundDictMapper.selectByExample(example)  ) –&gt; mappler. selectByexample–&gt; mapper.xml id = selectByexample</p>
<p>快看原来返回的是什么模型就已经告诉我了</p>
<p>list :</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn3vmitdelj307p08h756.jpg"></p>
<p>==list</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Page&lt;RoundDict&gt; roundDicts = roundDictService.getDicts(roundDictRequest.getDictId(),roundDictRequest.getDictUuid());<br><br>return this.setSysData(roundDicts);<br></code></pre></td></tr></table></figure>



<p> roundDictService.getDicts( ) –&gt; </p>
<p>Page<RoundDict> roundDicts  –&gt;  Page<RoundDict>?? –&gt; setSysData -&gt;  coreController.setSysData.setItem. –&gt; page data.getResult –&gt; PageData.setItems –&gt; ResponseMessage.setPageDate</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">setSysData(Page data形参） == setSysData(Page&lt;RoundDict&gt; roundDicts实参)<br> page.getResult return this<br>PageData.setItems( page data.getResult)  ==  PageData.setItems( Page&lt;RoundDict&gt; roundDicts.getResult )<br> <br></code></pre></td></tr></table></figure>



<p>page类 ：setStart </p>
<p><strong>SysPageBean : setItems</strong></p>
<p><strong>pageBean: setItems</strong></p>
<p>Corecontroller: roundDicts 需要有一个 getItems()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ResponseMessage&lt;SysPageBean&gt; <span class="hljs-title">setSysData</span><span class="hljs-params">(PageBean **data**)</span> </span>&#123;<br>    ResponseMessage&lt;SysPageBean&gt; responseMessage = <span class="hljs-keyword">new</span> ResponseMessage&lt;&gt;();<br>    SysPageBean pageData= <span class="hljs-keyword">new</span> SysPageBean();<br>    pageData.setTotal(Long.parseLong(data.getTotalNum() + <span class="hljs-string">&quot;&quot;</span>));<br>    <br>    pageData.setItems(**data**.getItems());<br>  <br>    responseMessage.setData(pageData);<br>    <span class="hljs-keyword">return</span> responseMessage;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>注解 for swagger</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">@RequestMapping(value = AdminRestUrl.ADD , method = RequestMethod.POST)<br>// 返回被@ApiModel标注的类对象。 啊哈哈这个会显示到swagger页面的这个接口最顶上。<br>@ApiOperation(value = &quot;实体类响应&quot;,notes = &quot;返回数据为实体类的接口&quot;)<br>//这个可能只对map生效哦，不过不确定<br>@ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细信息User&quot;, required = true,dataType = &quot;User&quot;)<br>public ResponseMessage&lt;Integer&gt; add(@RequestBody RoundDict roundDict) &#123;<br></code></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn3vq481onj306m01njri.jpg"></p>
<p>常用注解：<a href="https://github.com/Mshuyan/swagger">https://github.com/Mshuyan/swagger</a></p>
<p><a href="https://blog.csdn.net/weixin_44906271/article/details/105792809">https://blog.csdn.net/weixin_44906271/article/details/105792809</a></p>
<p>=====add</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">为什么insert、delete、update语句的返回值类型是int？<br></code></pre></td></tr></table></figure>

<p>有JDBC操作经验的朋友可能会有印象，增删改操作实际上返回的是操作的条数。而Mybatis框架本身是基于JDBC的，所以此处也沿袭这种返回值类型。</p>
<p>返回模型：<strong>ResponseMessage«Map» {</strong></p>
<p>resultStatus (code:1000,message:成功) ：getStatus,getcode/Message</p>
<p><strong>自定义（getDictId）</strong></p>
<p> return map(code,message)</p>
<p>–&gt;</p>
<p> ResponseMessage(    )   :ResponseMessage( resultStatus.<strong>自定义（getDictId）</strong> )  getData()</p>
<p> return map( code,message, dictId, dictum ….)</p>
<p>——》</p>
<p>Controller ()</p>
<p>Return ResponseMessage</p>
<p>responsebody?</p>
<p>\</p>
<p>发现我 “roomId”: 0,  “userId”: 0 已经成功删掉了，唯有action还很坚挺，可能在父类里面定义了。</p>
<p>资料：</p>
<p><a href="https://www.cnblogs.com/jackson0714/p/spring-boot-07-mybatis.html#_label0">MyBatis</a></p>
<p>mapper.xml中常用的标签详解：<a href="https://blog.csdn.net/qq_29233973/article/details/51433924">https://blog.csdn.net/qq_29233973/article/details/51433924</a></p>
<p><a href="https://www.cnblogs.com/aichiboluo/p/8962529.html">https://www.cnblogs.com/aichiboluo/p/8962529.html</a></p>
<p>深入解析mapper.xml： <a href="https://lanlan2017.github.io/JavaReadingNotes/f097c266/">https://lanlan2017.github.io/JavaReadingNotes/f097c266/</a></p>
<p>Mapper.xml 中的sql写法：<a href="https://blog.csdn.net/weixin_43925626/article/details/84940475?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control">https://blog.csdn.net/weixin_43925626/article/details/84940475?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control</a></p>
<p>Mapper.xml 中的sql写法：<a href="https://blog.csdn.net/weixin_30892037/article/details/97550213?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">https://blog.csdn.net/weixin_30892037/article/details/97550213?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control</a></p>
<p>sql 返回数据：<a href="https://www.cnblogs.com/ysySelf/p/11223971.html">https://www.cnblogs.com/ysySelf/p/11223971.html</a></p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>知乎流量之谜</title>
    <url>/hexo-blog/2020/12/19/%E7%9F%A5%E4%B9%8E%20csdn%E5%8F%91%E6%96%87%E7%AB%A0%20%E6%94%BE%E9%93%BE%E6%8E%A5%E5%88%B0%E7%9F%A5%E4%B9%8E%EF%BC%9F/</url>
    <content><![CDATA[<p>知乎流量之谜 <a href="https://www.zhihu.com/question/26004404/answer/916451048%E3%80%81">https://www.zhihu.com/question/26004404/answer/916451048、</a></p>
<p>选题：</p>
<p>除了技术流水账 还写些啥有自己感想的鸡汤文 批判文</p>
<p>我想写的技术点，如git 我如果看到已经有人写出非常好的内容的话，可以推荐给大家<br>我的核心价值点也许不在写代码教程（这个教程只是帮我自己梳理知识点）<br>核心在于 分享 我怎么转码的 经历，怎么高效转，怎么系统学， 我的程序生活 等等。<br>这些才是我独一无二的东西。</p>
]]></content>
      <tags>
        <tag>Writing</tag>
      </tags>
  </entry>
  <entry>
    <title>给自己的网站配置ssl证书</title>
    <url>/hexo-blog/2021/01/25/%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%AB%99%E9%85%8D%E7%BD%AEssl%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<h2 id="添加-ssl-证书"><a href="#添加-ssl-证书" class="headerlink" title="添加 ssl 证书"></a>添加 ssl 证书</h2><p>首先在平台上挑选一个免费的证书。</p>
<p>我尝试过 lets-encrypt， Zerossl， FreeSSL。</p>
<p>不过这些都比较不好，一方面是只有90天免费，另一方面是操作比较繁琐。</p>
<p>找来找去，最方便还好用的还是在阿里云上：有一个免费一年的证书叫 Symantec。</p>
<p>以下是一目了然的申请流程：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmzu7vy76jj30sx058wf7.jpg"></p>
<h4 id="1点这里购买免费证书"><a href="#1点这里购买免费证书" class="headerlink" title="1点这里购买免费证书"></a>1点<a href="https://market.aliyun.com/products/56824016/cmgj031379.html#sku=yuncode2537900001">这里</a>购买免费证书</h4><h4 id="2-到阿里云-管理控制台——云盾控制台——证书服务"><a href="#2-到阿里云-管理控制台——云盾控制台——证书服务" class="headerlink" title="2 到阿里云 管理控制台——云盾控制台——证书服务"></a>2 到阿里云 管理控制台——云盾控制台——<a href="https://yundunnext.console.aliyun.com/?p=casnext#/overview/cn-hangzhou">证书服务</a></h4><p>2.1 填写个人信息</p>
<p>2.2 生成 以下记录，复制这些记录</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>主机记录:</th>
<th>记录值:</th>
<th>T TL</th>
</tr>
</thead>
<tbody><tr>
<td>TXT</td>
<td>_dnsauth</td>
<td>xxxxxx</td>
<td>300</td>
</tr>
</tbody></table>
<p>2.3 去DNS解析记录:  hostinger - DNS</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmzu6o9ksyj307f069jrl.jpg"></p>
<h4 id="3-验证证书"><a href="#3-验证证书" class="headerlink" title="3 验证证书"></a>3 验证证书</h4><h4 id="回到阿里云证书服务平台"><a href="#回到阿里云证书服务平台" class="headerlink" title="回到阿里云证书服务平台"></a>回到<a href="https://yundunnext.console.aliyun.com/?spm=a2c4g.11186623.2.6.5c803c7erq432T&p=cas#/overview/cn-hangzhou">阿里云证书服务平台</a></h4><p> DNS 解析完后，证书就能验证成功啦</p>
<h4 id="4-等待证书的审核"><a href="#4-等待证书的审核" class="headerlink" title="4 等待证书的审核"></a>4 等待证书的审核</h4><h4 id="5-安装证书"><a href="#5-安装证书" class="headerlink" title="5 安装证书"></a>5 安装证书</h4><p>点开下载栏，有很多选择</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmzvytjtkxj30gw0b3mxu.jpg"></p>
<p>旁边有官方帮助，可根据介绍选择适合自己的版本</p>
<p>我选择的是nginx版。</p>
<p>安装有两种方式，</p>
<p>方法一（推荐）：</p>
<p>如果你的服务器已经安装好宝塔面板的非常推荐用这个方法。</p>
<p>如果没有的话，可以看看我前面的<a href="https://wenjialu.github.io/hexo_blog/2021/01/23/Google-Cloud-%E9%83%A8%E7%BD%B2%E6%88%91%E7%9A%84%E7%BD%91%E7%AB%99/">教程</a>，或者瞅一下方法二。</p>
<p><strong>到宝塔面板 - 网站 ；选择证书 - 其他证书</strong></p>
<p>复制前面我们所下载的证书文件中.key文件的内容粘贴到第一个文本框里，</p>
<p>复制另一个和key文件同名的那个.pem文件内容粘贴到第二个文本框里并保存。</p>
<p>就 ok 啦。</p>
<p>方法二：</p>
<p>按照官方的介绍下载。</p>
<p>我这里再描述下niginx 版的安装方式。</p>
<ol>
<li><p>在谷歌云的宝塔面板上找到自己的Nginx服务器。</p>
</li>
<li><p>我的Nginx安装目录是（/www/server/nginx/conf）, 在安装目录下创建一个用于存放证书的目录（命名为cert）。</p>
</li>
<li><p>使用宝塔的上传功能，将本地证书文件和密钥文件上传到Nginx服务器的证书目录（如 /www/server/nginx/conf/cert）</p>
</li>
<li><p>修改 nginx.conf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">server &#123;<br>    listen 443 ssl;<br>    #配置HTTPS的默认访问端口为443。<br>    #如果未在此处配置HTTPS的默认访问端口，可能会造成Nginx无法启动。<br>    #如果您使用Nginx 1.15.0及以上版本，请使用listen 443 ssl代替listen 443和ssl on。<br>    server_name yourdomain.com; #需要将yourdomain.com替换成证书绑定的域名。<br>    root html;<br>    index index.html index.htm;<br>    ssl_certificate cert/cert-file-name.pem;  #需要将cert-file-name.pem替换成已上传的证书文件的名称。<br>    ssl_certificate_key cert/cert-file-name.key; #需要将cert-file-name.key替换成已上传的证书密钥文件的名称。<br>    ssl_session_timeout 5m;<br>    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;<br>    #表示使用的加密套件的类型。<br>    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #表示使用的TLS协议的类型。<br>    ssl_prefer_server_ciphers on;<br>    location / &#123;<br>        root html;  #站点目录。<br>        index index.html index.htm;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>http 自动跳转到 https</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">server &#123;<br>    listen 80;<br>    server_name yourdomain.com; #需要将yourdomain.com替换成证书绑定的域名。<br>    rewrite ^(.*)$ https://$host$1; #将所有HTTP请求通过rewrite指令重定向到HTTPS。<br>    location / &#123;<br>        index index.html index.htm;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>重启 nginx</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">cd /www/server/nginx/sbin  #进入Nginx服务的可执行目录。<br>./nginx -s reload  #重新载入配置文件。<br></code></pre></td></tr></table></figure>





<h4 id="6-验证是否安装成功"><a href="#6-验证是否安装成功" class="headerlink" title="6 验证是否安装成功"></a>6 验证是否安装成功</h4><p>证书安装完成后，您可通过访问证书的绑定域名验证该证书是否安装成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">https://yourdomain.com   #需要将yourdomain.com替换成证书绑定的域名。<br></code></pre></td></tr></table></figure>

<p>如果你像我一样在浏览器框能看到这个小锁标志:</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmzx498na9j306100t3yi.jpg" alt="image-20210125142020794"></p>
<p>那就恭喜你啦 ～～～～</p>
<p>我们已经成功配置好了ssl证书。</p>
]]></content>
      <tags>
        <tag>Google Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>集成 Auzure ad 的 msal 库</title>
    <url>/hexo-blog/2021/03/19/%E9%9B%86%E6%88%90%20Auzure%20ad%20%E7%9A%84%20msal%20%E5%BA%93%20%E6%9D%A5%E7%AE%A1%E7%90%86&amp;%E4%BE%BF%E5%88%A9%E6%88%91%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<p>之前我写了一个简单的 web app：<a href="https://wenjialu.github.io/hexo_blog/2021/12/22/smartBrain%20react%20-%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%BD%91%E7%AB%99/">文章链接</a>🔗。</p>
<p>但是登录注册功能比较简单，而且要自己建数据库存储用户的信息。</p>
<p>正好最近有接触到微软的azure ad，它是企业级的授权验证方案，。。</p>
<p>可以方便app开发者和用户。。</p>
<p>所以我决定在我的应用中集成这个功能, 来管理&amp;便利我的用户登录 ～</p>
<p>Azure portal –&gt; app registration —&gt; register–&gt; 填写我的应用名称 + 重定向 URI <a href="https://wenjia-smart-brain.herokuapp.com/">https://wenjia-smart-brain.herokuapp.com/</a> –&gt; 在 <a href="https://portal.azure.com/?l=en.en-us#blade/Microsoft_AAD_RegisteredApps/ApplicationMenuBlade/Quickstart/quickStartType//sourceType/Microsoft_AAD_IAM/appId/7db5d000-e566-4ab0-a385-358b807c54fc/objectId/71296739-6f12-41a1-9584-0515d8b13907/isMSAApp//defaultBlade/Overview/appSignInAudience/AzureADandPersonalMicrosoftAccount/servicePrincipalCreated/true">Quickstart</a> 中按照说明下载对应app的文件并修改配置【<a href="https://docs.microsoft.com/zh-cn/azure/active-directory/develop/quickstart-v2-nodejs-webapp-msal?WT.mc_id=Portal-Microsoft_AAD_RegisteredApps">比如我的应用是 node.js 写的， 我就参考的是 node.js  应用的授权教程</a>】（鹿鹿贴心提醒，除了官方提醒，还别忘了修改redirect uri。）</p>
<ol>
<li>Go to the <a href="https://portal.azure.com/#blade/Microsoft_AAD_RegisteredApps/applicationsListBlade/quickStartType/PythonQuickstartPage/sourceType/docs">Azure portal - App registrations</a> quickstart experience.</li>
<li>Enter a name for your application and select <strong>Register</strong>.</li>
<li>Follow the instructions to download and automatically configure your new application.</li>
</ol>
<p>成功后就可以访问 127.0.0.1:3000, 可以看到：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvp4s0l1iej60be0dwgm602.jpg"></p>
<p>报错：（鹿鹿贴心提醒，除了官方提醒，还别忘了修改redirect uri。不然会有以下报错。）</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvp4mbgcmfj60hn0i6my902.jpg"></p>
<p>如果遇到问题，可以通过 <a href="https://github.com/wenjialu">https://github.com/wenjialu</a> 给我留言～</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/hexo-blog/2021/01/12/%E9%A1%B9%E7%9B%AE%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>项目重要问题记录：</p>
<p>smart brain： 后端接口</p>
<p>bloghelper：es6 语法的支持</p>
<p>to do list : local storage</p>
]]></content>
  </entry>
  <entry>
    <title>SmartBrain -  用 React 做一个人脸识别网站</title>
    <url>/hexo-blog/2021/12/22/smartBrain%20react%20-%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="用-React-做一个人脸识别网站"><a href="#用-React-做一个人脸识别网站" class="headerlink" title="用 React 做一个人脸识别网站"></a>用 React 做一个人脸识别网站</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>React 可以说是近些年最热门的前端框架啦， 并且非常非常的好用 ~</p>
<p>很多的国外公司比如 <a href="https://zh.wikipedia.org/wiki/Netflix">Netflix</a>、<a href="https://zh.wikipedia.org/wiki/Feedly">Feedly</a>、<a href="https://zh.wikipedia.org/wiki/Airbnb">Airbnb</a> 都是用它来实现的网站主页。</p>
<p>那么 React 到底是个什么呢？它其实是一个为数据提供渲染为<a href="https://zh.wikipedia.org/wiki/HTML">HTML</a>视图的<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6">开源</a><a href="https://zh.wikipedia.org/wiki/JavaScript%E5%87%BD%E5%BC%8F%E5%BA%93">JavaScript 库</a>。传说最早起源于Facebook 的内部项目，由于太好用了，就开源给大家使用了。</p>
<p>现在国内的很多公司都在招聘会 React 的前端工程师。说明如果会这项技术还是会很吃香哒。</p>
<p>那么我们应该怎么学习它呢？ </p>
<p><a href="https://zh-hans.reactjs.org/docs/hello-world.html">官方文档</a>当然是一个选择 ～</p>
<p>里面有官方人员给出的最严谨的定义和最全的方法解释，一步一步跟着学的话应该也能学会。</p>
<p>不过，稍显有那么点点枯燥啦。</p>
<p><strong>想要更好玩的学习方法，不妨找个小项目来上手吧。</strong></p>
<p>因为根据认知心理学的理论，学习的最好方法之一就是应用 ～</p>
<p>在“做中学” 会比单纯的 “看概念” 更记忆深刻哦 ～</p>
<p>我之前在初步学习 react 的时候，有小试牛刀，</p>
<p>做了一个机器人🤖️网站，网址在这里：<a href="https://rocky-hamlet-79784.herokuapp.com/">https://rocky-hamlet-79784.herokuapp.com/</a>  。教程在此：</p>
<p>今天想教大家一个升级版！！！一个可以有用户的人脸识别网站～</p>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><a href="https://wenjia-smartbrain.herokuapp.com/">https://wenjia-smartbrain.herokuapp.com/</a> （还没完全完成好）</p>
<p>由于教程篇幅过长，将会分成四个部分：前端篇、后端篇、数据库篇 和 部署篇。</p>
<p>跟着我一起学完，不仅能掌握 react 框架的使用，还能拥有一个炫酷的网站哦～～</p>
<h2 id="源码-（hide）"><a href="#源码-（hide）" class="headerlink" title="源码 （hide）"></a>源码 （hide）</h2><p>Front end: <a href="https://github.com/aneagoie/smart-brain">https://github.com/aneagoie/smart-brain</a></p>
<p>Back end: <a href="https://github.com/aneagoie/smart-brain-api">https://github.com/aneagoie/smart-brain-api</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Final project <span class="hljs-keyword">for</span> ZTM course<br><br>    Clone this repo<br>    Run npm install<br>    Run npm start<br>    You must add your own API key <span class="hljs-keyword">in</span> the src/App.js file to connect to Clarifai.<br><br>You can grab Clarifai API key here<br></code></pre></td></tr></table></figure>



<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>前端的页面想设计成这样：</p>
<p>![未命名文件 (2)](/Users/lujiawen/Desktop/未命名文件 (2).png)</p>
<p>首页可以拆分成3个元素， 分别是登录、注册、导航栏。</p>
<p>那就每个元素做成一个组件。</p>
<p>登录后的页面</p>
<p>![未命名文件 (1)](/Users/lujiawen/Desktop/未命名文件 (1).png)</p>
<p>可以拆分成4 个模块。除去导航栏，还有logo、搜索框、面部识别功能区。</p>
<p>设计component，并放在app.js中 。</p>
<p>tips：app.js中的多个 components 要放在 <div></div> 里面哦。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>function App() &#123;<br>  return (<br>    &lt;div&gt;<br>       &lt;Navigation /&gt;<br>       &lt;Logo /&gt; <br>        &lt;ImageLinkForm/&gt;<br>        &lt;FaceRecognition /&gt;<br><br>    &lt;/div&gt;<br><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure>







<h3 id="注册-登录功能"><a href="#注册-登录功能" class="headerlink" title="注册, 登录功能"></a>注册, 登录功能</h3><h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><p>Google 搜索 tachyons + forms,  tachyons + card 加个边框</p>
<p>页面预览和代码都有啦～～</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> Signin = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span>(<br>        <span class="hljs-comment">// 这里放html代码, </span><br>       <span class="hljs-comment">//不过记得把input 像这样 /&gt; close 掉. for 要改成htmlFor, class 改成 className</span><br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center br3 ba b--black-10 mv4 w-100 w-50-m w-25-l shadow-5 mw6 center&quot;</span>&gt;</span></span><br><span class="xml">        ...</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">article</span> /&gt;</span>  </span><br><span class="xml">    )</span><br><span class="xml">&#125;</span><br><span class="xml"></span><br><span class="xml">export default Signin;</span><br></code></pre></td></tr></table></figure>

<p>自行删删改改</p>
<h4 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h4><p>App.js</p>
<p>功能： 没 signin 之前是signin 页面， signin 之后是rank+上传image 页面。</p>
<p>实现： constructor()</p>
<p>tips:  jsx语法： html 里加了{  } 就可以写 js 了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">super</span>()<br>    <span class="hljs-built_in">this</span>.state = &#123;<br>      <span class="hljs-attr">input</span>: <span class="hljs-string">&quot;&quot;</span>,<br>      <span class="hljs-attr">route</span>: <span class="hljs-string">&quot;signin&quot;</span><br>    &#125;<br>  &#125;<br><br><br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="xml">         <span class="hljs-tag">&lt;<span class="hljs-name">Navigation</span> /&gt;</span></span><br><span class="xml">         &#123; this.state.route === &quot;signin&quot;</span><br><span class="xml">          ?  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&lt; Signin /&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>          :  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> </span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Logo</span> /&gt;</span> </span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Rank</span> /&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">ImageLinkForm</span> <span class="hljs-attr">onInputChange</span>=<span class="hljs-string">&#123;this.onInputChange&#125;</span> <span class="hljs-attr">onButtonSubmit</span>=<span class="hljs-string">&#123;this.onButtonSubmit&#125;/</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">FaceRecognition</span> /&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Particles</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;particles&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">                  <span class="hljs-attr">params</span>=<span class="hljs-string">&#123;particleOptions&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">                /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>         &#125;   <br>      &lt;/div&gt;<br>  <br>    );<br>    &#125;<br>  &#125;<br>   <br><br></code></pre></td></tr></table></figure>

<p>同理，新建 register 页面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">// 新增代码<br> &lt;div className=&quot;mt3&quot;&gt;<br>                &lt;label className=&quot;db fw6 lh-copy f6&quot; htmlFor=&quot;name&quot;&gt;Name&lt;/label&gt;<br>                &lt;input<br>                  className=&quot;pa2 input-reset ba bg-transparent hover-bg-black hover-white w-100&quot;<br>                  type=&quot;text&quot;<br>                  name=&quot;name&quot;<br>                  id=&quot;name&quot;<br>                  onChange=&#123;this.onNameChange&#125;<br>                /&gt;<br>              &lt;/div&gt;<br></code></pre></td></tr></table></figure>





<h4 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h4><p>设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">constructor()&#123;<br>    super()<br>    this.state = &#123;<br>      input: &quot;&quot;,<br>      route: route<br>      // route: &quot;signin&quot;<br>    &#125;<br>  &#125;<br>  <br>  <br>  onRouteChange = (route) =&gt; &#123;<br>    this.setState(&#123;route: route&#125;);<br>  &#125;<br><br>render() &#123;<br>    return (<br>      &lt;div className=&quot;App&quot;&gt;<br>         &lt;Navigation onRouteChange = &#123;this.onRouteChange&#125;/&gt;<br>         &#123; this.state.route === &quot;signin&quot;<br>          ?  &lt;div&gt;<br>              &lt;Signin /&gt;<br>              &lt;Particles className=&quot;particles&quot;<br>                    params=&#123;particleOptions&#125; /&gt;<br>              &lt;/div&gt;<br>          :  &lt;div&gt; <br>              &lt;Logo /&gt; <br>              &lt;Rank /&gt;<br>              &lt;ImageLinkForm onInputChange=&#123;this.onInputChange&#125; onButtonSubmit=&#123;this.onButtonSubmit&#125;/&gt;<br>              &lt;FaceRecognition /&gt;<br>              &lt;Particles className=&quot;particles&quot;<br>                    params=&#123;particleOptions&#125;<br>                /&gt;&lt;/div&gt;<br>         &#125;   <br>      &lt;/div&gt;<br>  <br>    );<br>    &#125;<br></code></pre></td></tr></table></figure>







<p>添加：思路；需要跳转到什么页面， onRouteChange(param)}， param就写什么参数。</p>
<p>tips： 千万别忘了在函数头传参{onRouteChange} ！！！！！</p>
<p>Navigation.js  (signout button)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">onClick=&#123;(&#123;onRouteChange&#125;) =&gt; onRouteChange(&quot;signin&quot;)&#125;<br></code></pre></td></tr></table></figure>



<p>Signin.js </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">// 千万别忘了传参&#123;onRouteChange&#125; ！！！！！<br>// 箭头函数：render的时候不调用这个函数，只有当onClick的时候才调用<br>//            onClick = &#123;() =&gt; onRouteChange(&quot;rankpage&quot;)&#125;<br>            <br>     &lt;div class=&quot;&quot;&gt;<br>            &lt;input <br>            // 箭头函数：render的时候不调用这个函数，只有当onClick的时候才调用<br>            onClick = &#123;() =&gt; onRouteChange(&quot;rankpage&quot;)&#125;<br>            className=&quot;b ph3 pv2 input-reset ba b--black bg-transparent grow pointer f6 dib&quot; <br>            type=&quot;submit&quot; <br>            value=&quot;Sign in&quot; /&gt;<br>            &lt;/div&gt;<br>            &lt;div class=&quot;lh-copy mt3&quot;&gt;<br>            &lt;a onClick = &#123;() =&gt; onRouteChange(&quot;register&quot;)&#125; href=&quot;#0&quot; className=&quot;f6 link dim black db&quot;&gt;Register&lt;/a&gt;<br>                        &lt;/div&gt;       <br>            <br></code></pre></td></tr></table></figure>



<p>Register</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;input <br>  // 箭头函数：render的时候不调用这个函数，只有当onClick的时候才调用<br>  onClick = &#123;() =&gt; onRouteChange(&quot;signin&quot;)&#125;<br>  className=&quot;b ph3 pv2 input-reset ba b--black bg-transparent grow pointer f6 dib&quot; <br>  type=&quot;submit&quot; <br>  value=&quot;Register&quot; /&gt;<br>  &lt;/div&gt;<br></code></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="上传照片并识别"><a href="#上传照片并识别" class="headerlink" title="上传照片并识别"></a>上传照片并识别</h3><ol>
<li><p>识别输入框的内容（url）： 设置state：input</p>
</li>
<li><p>Detect 按钮识别输入框的图片url：imagelinkform component(oninputchange + onbuttonsubmit)。</p>
</li>
<li><p>在输入框下方展示url中的照片：FaceRecognition component.</p>
</li>
<li><p>识别照片中的人脸：clarifai</p>
</li>
<li><p>标示人脸：查看 clarifai 的 response –&gt;写入到 FaceRecognition component.</p>
</li>
</ol>
<h4 id="Step-1-输入框，按钮框对于输入的识别"><a href="#Step-1-输入框，按钮框对于输入的识别" class="headerlink" title="Step 1. 输入框，按钮框对于输入的识别"></a>Step 1. 输入框，按钮框对于输入的识别</h4><p>App.js 设置 state,并渲染</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">constructor()&#123;<br>    super()<br>    this.state = &#123;<br>      input: &quot;&quot;<br>    &#125;<br>  &#125;<br><br>  onInputChange = (event) =&gt; &#123;<br>    console.log(event.target.value);<br>  &#125;<br><br>  onButtonSubmit = () =&gt; &#123;<br>    console.log(&quot;click&quot;);<br>  &#125;<br>  <br>render() &#123;<br>    return (<br>      &lt;div className=&quot;App&quot;&gt;<br>  <br>          &lt;ImageLinkForm onInputChange=&#123;this.onInputChange&#125; onButtonSubmit=&#123;this.onButtonSubmit&#125;/&gt;<br>         <br>      &lt;/div&gt;<br>  <br>    );<br>    &#125;  <br></code></pre></td></tr></table></figure>





<p>ImageLinkForm.js</p>
<p>传参，用参</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;input className=&quot;f4 pa2 w-70 center&quot; type=&quot;text&quot; onChange=&#123;onInputChange&#125;/&gt;<br> &lt;button className=&quot;w-30 grow f4 link ph3 pv2 dib white bg-light-purple&quot; <br>                   onClick = &#123;onButtonSubmit&#125;&gt;Detect&lt;/button&gt;<br>           <br></code></pre></td></tr></table></figure>



<h4 id="step-2-能上传图片"><a href="#step-2-能上传图片" class="headerlink" title="step 2. 能上传图片"></a>step 2. 能上传图片</h4><p>调用人家已经做好的api</p>
<p>clarifai （<a href="https://www.clarifai.com/%EF%BC%89">https://www.clarifai.com/）</a></p>
<p>注册一个账户就能免费用了</p>
<h4 id="step-3-展示图片"><a href="#step-3-展示图片" class="headerlink" title="step 3. 展示图片"></a>step 3. 展示图片</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">const FaceRecognition = (&#123; imageUrl, box &#125;) =&gt; &#123;<br>    return (<br>      &lt;div className=&#x27;center ma&#x27;&gt;<br>  <br>      &lt;div className=&#x27;absolute mt2&#x27;&gt;<br>        &#123;/* 下面这行是关键的代码，通过src展示url对应的图片 */&#125; &#123;/* width， height固定图片大小 */&#125;<br>        &lt;img id=&#x27;inputimage&#x27; alt=&#x27;&#x27; src=&#123;imageUrl&#125; width=&#x27;500px&#x27; heigh=&#x27;auto&#x27;/&gt;<br>        &#123;/* 标示人脸 */&#125;<br>        &lt;div className=&#x27;bounding-box&#x27; style=&#123;&#123;top: box.topRow, right: box.rightCol, bottom: box.bottomRow, left: box.leftCol&#125;&#125;&gt;&lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>    );<br>  &#125;<br></code></pre></td></tr></table></figure>



<h4 id="step4能识别图片"><a href="#step4能识别图片" class="headerlink" title="step4能识别图片"></a>step4能识别图片</h4><p>调用人家已经做好的api, 注册一个账户就能免费用了</p>
<h5 id="查看文档"><a href="#查看文档" class="headerlink" title="查看文档"></a>查看文档</h5><p>clarifai （<a href="https://www.clarifai.com/%EF%BC%89">https://www.clarifai.com/）</a></p>
<p>Model-&gt;face dectection = <a href="https://www.clarifai.com/models/face-detection">https://www.clarifai.com/models/face-detection</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">https://clarifai.com/developer/<br>docs.clarifai.com/api-guide/predict/images<br></code></pre></td></tr></table></figure>

<p>Google：npm clarifai -&gt; GitHub 源码 -&gt; 里面有所有的模型</p>
<h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><p>npm install clarifai</p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">const Clarifai = require(&#x27;clarifai&#x27;);<br><br>//You must add your own API key here from Clarifai. <br><br>const app = new Clarifai.App(&#123;<br><br> apiKey: &#x27;注册后就有了&#x27;<br><br>&#125;);<br><br>...除了人脸识别，还可以使用clarifai上不同的模型做不同的事情（识别色彩，理解图片，识别视频。。。）<br><br></code></pre></td></tr></table></figure>



<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="css-部分"><a href="#css-部分" class="headerlink" title="css 部分"></a>css 部分</h3><p>因为要花好多时间调试好看的样式，而样式会根据项目的不同而进行很大的调整。</p>
<p>所以这里具体样式就直接给大家了，就不用花太多时间纠结样式了。</p>
<h4 id="Magic-1-tachyons"><a href="#Magic-1-tachyons" class="headerlink" title="Magic 1. tachyons"></a>Magic 1. tachyons</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm install tachyons<br>npm tachyons<br><br></code></pre></td></tr></table></figure>

<h5 id="Index-js-导入"><a href="#Index-js-导入" class="headerlink" title="Index.js 导入"></a>Index.js 导入</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import &quot;tachyons&quot;;<br></code></pre></td></tr></table></figure>

<h5 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h5><h6 id="Naviation-js"><a href="#Naviation-js" class="headerlink" title="Naviation.js"></a>Naviation.js</h6><p>Q: 是怎么知道里面的样式呢。</p>
<p>A:</p>
<ol>
<li><a href="https://tachyons.io/#style">https://tachyons.io/#style</a> style guide</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;nav style = &#123;&#123;display: &quot;flex&quot;, justifyContent: &quot;flex-end&quot;&#125;&#125;&gt;<br>     &lt;p className=&quot;f3 link dim black underline pa3 pointer&quot;&gt;Sign Out&lt;/p&gt;<br>   &lt;/nav&gt;<br></code></pre></td></tr></table></figure>

<p>长这样：</p>
<p>![image-20201120171507674](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201120171507674.png)</p>
<ol start="2">
<li><p>Google 搜索 tachyons + 关键词</p>
<p>eg. tachyons  form</p>
<p>页面预览和代码都有啦～～</p>
</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> Signin = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span>(<br>        <span class="hljs-comment">// 这里放html代码, 不过记得把input 像这样 /&gt; close 掉. for 要改成htmlFor</span><br>        ...<br>    )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Signin;<br></code></pre></td></tr></table></figure>


<p>   ![image-20201202211043579](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201202211043579.png)</p>
<p>Ps. 关于className.</p>
<p>自己在app.css logo.css 里面定义的class 也可以用className 引用</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.center</span>&#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure>





<h4 id="Magic-2-React-tilt-（for-Logo）"><a href="#Magic-2-React-tilt-（for-Logo）" class="headerlink" title="Magic 2. React-tilt （for Logo）"></a>Magic 2. React-tilt （for Logo）</h4><p>React-tilt library 可以有炫酷的交互。</p>
<p>去它的网站上看安装和使用方式，直接复制就能用了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm install --save react-tilt<br></code></pre></td></tr></table></figure>

<p>好可爱，喜欢</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import Tilt from &#x27;react-tilt&#x27;<br> <br>&lt;Tilt className=&quot;Tilt&quot; options=&#123;&#123; max : 25 &#125;&#125; style=&#123;&#123; height: 250, width: 250 &#125;&#125; &gt;<br> &lt;div className=&quot;Tilt-inner&quot;&gt; 👽 &lt;/div&gt;<br>&lt;/Tilt&gt;<br></code></pre></td></tr></table></figure>

<p>可以加一些css样式</p>
<p>然后把👽换成自己的logo （没有的话去Google一个免费的）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import brain from &quot;./xx.png&quot;;<br><br>&lt;img alt=&quot;logo&quot; src=&#123;brain&#125; /&gt;<br></code></pre></td></tr></table></figure>



<h4 id="Magic-3-linear-gradient-for-background"><a href="#Magic-3-linear-gradient-for-background" class="headerlink" title="Magic 3. linear-gradient (for background)"></a>Magic 3. linear-gradient (for background)</h4><p>自己去Google一个好看的linear-gradient。</p>
<p>Index.css (index的样式会影响整个项目)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">body &#123;<br>  margin: 0;<br>  padding: 0;<br>  font-family: sans-serif;<br>  background: linear-gradient(89deg, #e66465 0% , #9198e5 100%);<br>&#125;<br>/* linear-gradient(89deg, #FF5EDF 0%, #04C8DE 100%); */<br><br>/* 手指 */<br>button&#123;<br>  cursor: pointer;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="Magic-4-Particles-js-for-background"><a href="#Magic-4-Particles-js-for-background" class="headerlink" title="Magic 4. Particles.js  (for background)"></a>Magic 4. Particles.js  (for background)</h4><p>超炫酷！！！！动态背景</p>
<p>react 版本： 搜索  react Particles npm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm install react-particles-js<br></code></pre></td></tr></table></figure>

<p>app.css </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>.particles&#123;<br>  position: fixed; <br>  top: 0;<br>  right: 0;<br>  bottom: 0;<br>  left: 0;<br>  /* 这样就能不覆盖其他层了 */<br>  z-index: -1;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>app.js </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">const particleOptions = &#123;<br>  particles: &#123;<br>    number:&#123;<br>      value: 200,<br>      density: &#123;<br>        enable: true,<br>        value_are: 800<br>      &#125;<br>    &#125;<br>    // ,<br>      // shape: &#123;<br>      //     type: &#x27;images&#x27;,<br>      //     image: [<br>      //         &#123;src: &#x27;path/to/first/image.svg&#x27;, height: 20, width: 20&#125;,<br>      //         &#123;src: &#x27;path/to/second/image.jpg&#x27;, height: 20, width: 20&#125;,<br>      //     ]<br>      // &#125;<br>  &#125;<br>&#125;<br><br><br>在render里面第一个使用这个模块。<br></code></pre></td></tr></table></figure>



<p>参数再研究下让他能互动！</p>
<h4 id="Magic-5-css3-partern-gallery"><a href="#Magic-5-css3-partern-gallery" class="headerlink" title="Magic 5. css3 partern gallery"></a>Magic 5. css3 partern gallery</h4><p><a href="http://projects.verou.me/css3patterns/">http://projects.verou.me/css3patterns/</a></p>
<p>#### </p>
<p>ps. 关于 <code>&lt;React.StrictMode&gt;&lt;/React.StrictMode&gt;</code></p>
<p>In index.js change <code>&lt;React.StrictMode&gt;&lt;App /&gt;&lt;/React.StrictMode&gt;</code> to <code>&lt;App /&gt;</code> and you will not see this warning. Please note that strict mode helps you with</p>
<ul>
<li>Identifying components with unsafe lifecycles</li>
<li>Warning about legacy string ref API usage</li>
<li>Warning about deprecated findDOMNode usage</li>
<li>Detecting unexpected side effects</li>
<li>Detecting legacy context API</li>
</ul>
<p>Please refer to <a href="https://reactjs.org/docs/strict-mode.html">https://reactjs.org/docs/strict-mode.html</a> before removing it.</p>
<h3 id="状态转化总结-⭐️⭐️⭐️"><a href="#状态转化总结-⭐️⭐️⭐️" class="headerlink" title="状态转化总结 ⭐️⭐️⭐️"></a>状态转化总结 ⭐️⭐️⭐️</h3><p>(可以放到 react 教程中)</p>
<p>App.js</p>
<p>1 设置 constructor: 创建state, 初始值可以随便设不影响（因为目的是创建出state，初始值不是很重要），比如设置空“”</p>
<p>tips：js里面布尔值false才是F， 字符串“false”是T。所以不能加引号哦。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 需要时要传 props <br>constructor()&#123;<br>    super()<br>    this.state = &#123;<br>      input: &quot;&quot;,<br>      route: &quot;swf&quot;,<br>      isSignedIn:false<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>



<p>2 设置事件函数：</p>
<p>函数功能：setState</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">onRouteChange = (route) =&gt; &#123;<br>   if (route === &#x27;signout&#x27;) &#123;<br>     this.setState(&#123;isSignedIn: false&#125;)<br>   &#125; else if (route === &#x27;rankpage&#x27;) &#123;<br>     this.setState(&#123;isSignedIn: true&#125;)<br>   &#125;<br><br>   this.setState(&#123;route: route&#125;);<br> &#125;<br></code></pre></td></tr></table></figure>



<p>函数功能：联系后端</p>
<p>ps. This.props 表示全局都能用啦～</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>// 箭头函数：render的时候不调用这个函数，只有当onClick的时候才调用<br>onSubmitSignIn = () =&gt; &#123;<br>    fetch(&quot;http://localhost:3000/signin&quot;,<br>    &#123;<br>        method:&quot;post&quot;,<br>        headers:&#123;&quot;Content-Type&quot;:&quot;application/json&quot;&#125;,<br>        body:JSON.stringify(&#123;<br>            name: this.state.name,<br>            email: this.state.email,<br>            password: this.state.password<br>        &#125;)<br>            .then(response =&gt; response.json())<br>            // 传参，传user<br>            .then(user =&gt;&#123;<br>                if (user.id)&#123;<br>                    this.props.loadUser(user)<br>                    this.props.onRouteChange(&quot;rankpage&quot;)<br>                &#125;<br>            &#125;)<br>    &#125;)<br>    console.log(this.state);<br>&#125;<br><br></code></pre></td></tr></table></figure>







<p>3 渲染 </p>
<p>Tips: onRouteChange 是函数，调用的时候要this.onRouteChange</p>
<p>isSignedIn 是状态，调用的时候要this.state.isSignedIn</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;Navigation isSignedIn = &#123;this.state.isSignedIn&#125; onRouteChange = &#123;this.onRouteChange&#125;/&gt;<br></code></pre></td></tr></table></figure>



<p>Component </p>
<p>根据具体情况调用函数传参，以供渲染</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Navigation</span>(<span class="hljs-params">&#123;onRouteChange, isSignedIn&#125;</span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (isSignedIn)&#123;<br>        <span class="hljs-keyword">return</span> (<br>          <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">style</span> = <span class="hljs-string">&#123;&#123;display:</span> &quot;<span class="hljs-attr">flex</span>&quot;, <span class="hljs-attr">justifyContent:</span> &quot;<span class="hljs-attr">flex-end</span>&quot;&#125;&#125;&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> onRouteChange(&quot;signout&quot;)&#125; className=&quot;f3 link dim black underline pa3 pointer&quot;&gt;Sign Out<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span></span>)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">style</span> = <span class="hljs-string">&#123;&#123;display:</span> &quot;<span class="hljs-attr">flex</span>&quot;, <span class="hljs-attr">justifyContent:</span> &quot;<span class="hljs-attr">flex-end</span>&quot;&#125;&#125;&gt;</span></span><br><span class="xml">              <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> onRouteChange(&quot;signin&quot;)&#125; className=&quot;f3 link dim black underline pa3 pointer&quot;&gt;Sign in<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  </span><br><span class="xml">              <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> onRouteChange(&quot;register&quot;)&#125; className=&quot;f3 link dim black underline pa3 pointer&quot;&gt;Register<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">           </span><br><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span></span>);         <br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>





<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="开始搭建服务器"><a href="#开始搭建服务器" class="headerlink" title="开始搭建服务器"></a>开始搭建服务器</h3><p>有了服务器就能有真的用户注册，登出功能啦～</p>
<h4 id="新建一个-smartbrain-api-文件夹"><a href="#新建一个-smartbrain-api-文件夹" class="headerlink" title="新建一个 smartbrain-api 文件夹"></a>新建一个 smartbrain-api 文件夹</h4><ol>
<li>npm init</li>
</ol>
<p>安装一些依赖，如express， nodemon 等 （npm install xxx）</p>
<p>![image-20201120220035314](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201120220035314.png)</p>
<p>Nodemon: automatically restarts node when file changes are detected in a directory. It replaces the word node when executing a script.<br>npm install –save-dev nodemon</p>
<ol start="2">
<li>在文件夹里面新建一个 server.js</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);<br><br><span class="hljs-keyword">const</span> app = express();<br><br>app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;3000&quot;</span>)<br>&#125;<br>)<br></code></pre></td></tr></table></figure>


<p>   在脚本里面设置每次 npm start 自动启动server.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&quot;scripts&quot;: &#123;<br>  &quot;start&quot;: &quot;nodemon server.js&quot;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>服务器就搭好了。</p>
<h3 id="确定后端-api-元素-通过看一下前端页面"><a href="#确定后端-api-元素-通过看一下前端页面" class="headerlink" title="确定后端 api 元素 - 通过看一下前端页面"></a>确定后端 api 元素 - 通过看一下前端页面</h3><p>前端register页面有3个元素</p>
<p>login 里面有名字，rank，上传的图片数</p>
<h4 id="初步的设计"><a href="#初步的设计" class="headerlink" title="初步的设计"></a>初步的设计</h4><p>// register –&gt; req: POST  res: user </p>
<p>// signin –&gt; req: POST  res: success/fail </p>
<p>// profile userId –&gt; GET res: user </p>
<p>// image –&gt; PUT (更新) res: user count </p>
<h3 id="实现-api-元素"><a href="#实现-api-元素" class="headerlink" title="实现 api 元素"></a>实现 api 元素</h3><p>既然已经确定了前端页面元素，现在不用管前端了。用postman来模拟前端request ，并接受后端response</p>
<h5 id="register"><a href="#register" class="headerlink" title="register"></a>register</h5><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">app.post(<span class="hljs-string">&quot;/register&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123;email, name, password&#125; = req.body<br>    database.users.push(&#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;125&quot;</span>,<br>        <span class="hljs-attr">name</span>: name,<br>        <span class="hljs-attr">email</span>: email,<br>        <span class="hljs-attr">password</span>: password,<br>        <span class="hljs-attr">entries</span>: <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">joined</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br>    &#125;)<br>    res.json(database.users[database.users.length - <span class="hljs-number">1</span>])<br>    <br>&#125;)<br></code></pre></td></tr></table></figure>

<p>![image-20201202165908426](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201202165908426.png)</p>
<h5 id="signin"><a href="#signin" class="headerlink" title="signin"></a>signin</h5><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 如果用户psot的在数据库里面，就返回</span><br>app.post(<span class="hljs-string">&quot;/signin&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (req.body.email === database.users[<span class="hljs-number">1</span>].email &amp;&amp;<br>        req.password === database.users[<span class="hljs-number">1</span>].password)&#123;<br>            res.json(<span class="hljs-string">&quot;success&quot;</span>)<br>        &#125; <span class="hljs-keyword">else</span>&#123; <br>            res.status(<span class="hljs-number">400</span>).json(<span class="hljs-string">&quot;fail&quot;</span>)<br>        &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>



<h5 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h5><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 好像有点问题，只能获取到第一个 123</span><br>app.get(<span class="hljs-string">&quot;/profile/:id&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span>&#123;<br>    <span class="hljs-keyword">const</span> &#123;id&#125; = req.params;<br>    <span class="hljs-keyword">let</span> found = <span class="hljs-literal">false</span><br>    database.users.forEach(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span>&#123;<br>        <span class="hljs-keyword">if</span> (user.id === id)&#123;<br>            found = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span> res.json(user);<br>        &#125; <br>        <span class="hljs-keyword">if</span> (!found)&#123;<br>            res.status(<span class="hljs-number">400</span>).json(<span class="hljs-string">&quot;not found&quot;</span>)      <br>        &#125;     <br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>



<p>Image  for rank</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><br>app.put(<span class="hljs-string">&quot;/image&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123;id&#125; = req.params;<br>    <span class="hljs-keyword">let</span> found = <span class="hljs-literal">false</span><br>    database.users.forEach(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span>&#123;<br>        <span class="hljs-keyword">if</span> (user.id === id)&#123;<br>            user.entries++;<br>            <span class="hljs-keyword">return</span> res.json(user.entries);<br>        &#125; <br>        <span class="hljs-keyword">if</span> (!found)&#123;<br>            res.status(<span class="hljs-number">400</span>).json(<span class="hljs-string">&quot;not found&quot;</span>)      <br>        &#125;     <br>&#125;)<br></code></pre></td></tr></table></figure>













<h3 id="用户密码安全🔐"><a href="#用户密码安全🔐" class="headerlink" title="用户密码安全🔐"></a>用户密码安全🔐</h3><p>这个项目里用 bcrypt-nodejs    实际用bcrypt.js 或者 bcrypt</p>
<p>通过hash 对用户密码加密</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">We prefer bcrypt for three reasons:  1. bcrypt is 15 years old and has been vetted by the crypto community. Although argon2 won last year’s password hashing competition, it is still fairly new and we would like to see it have a longer lifespan in the crypto community.  2. scrypt is 7 years old and also a good choice, but bcrypt is a bit easier to implement in a node.js server with simpler documentation as you will see below in the example.  3. The bcrypt npm package is better over other bcrypt implementations available on npm since it is native, highly popular, and vetted by the community without trying to reinvent the wheel.<br><br>Now you might be asking yourself, why not just use a hashing function like SHA256, add a salt (randomly generated bytes to place in front of the password) for each user, and store those in a database? The problem with computing power increasing is that attackers can now use GPUs to try out passwords at over 100 million per second and see if they get a hit. That’s why you want to use hash functions that were specifically designed to be slow. Although it is fast enough so the user won’t notice (about 100ms), it is long enough to make it infeasible for an attacker to try out a long list of passwords. bcrypt allows you to add a saltRound (10 is the recommended value) which iterates 2^10, or 1024 times over the password in a process called key stretching. Finally, bcrypt implementation is also safe from timing attacks. <br><br>---- udemy<br></code></pre></td></tr></table></figure>



<h3 id="连接上前端"><a href="#连接上前端" class="headerlink" title="连接上前端"></a>连接上前端</h3><p>前后端在现实中应该在不同的电脑上。</p>
<p>后端 端口：3000</p>
<p>前端 端口：3001</p>
<p>先启动后端，再启动前端。会提示我port被占用要不要换，按y就会换到新端口了。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>在前端 fetch 后端根路径/的响应，并在渲染的时候打印出来。</p>
<p>根路径在后端设置返回的是用户数据。</p>
<p>可以在浏览器里面看到打印出了用户数据，获取成功～</p>
<p>![image-20201204234706807](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201204234706807.png)</p>
<h4 id="前端代码改写"><a href="#前端代码改写" class="headerlink" title="前端代码改写"></a>前端代码改写</h4><p>Signin.js</p>
<p>Const 改为 class， 目的是能够加上监听输入框状态的方法。</p>
<p>因为这些是只和 signin 有关的智能状态，可以写在 component-signin.js 里面。不用写在 app.js 里面让他变得好臃肿。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#变为class的操作<br>1. class Signin extends React.Component &#123;<br> render()&#123;<br> 	return()<br> &#125;<br>2. const &#123;onRouteChange&#125; = this.props;<br><br># 状态<br>1 constructor(props)&#123;<br>       super(props);<br>       this.state =  &#123;<br>           signInEmail:&quot;&quot;,<br>           signInPassword:&quot;&quot; <br>       &#125;<br>    &#125;<br><br> 2   onEmailChange = (event) =&gt; &#123;<br>        this.setState(&#123;signInEmail: event.target.value &#125;)<br>    &#125;<br><br>    onPasswordChange = (event) =&gt; &#123;<br>        this.setState(&#123;signInPassword: event.target.value &#125;)<br>    &#125;<br><br>    // 箭头函数：render的时候不调用这个函数，只有当onClick的时候才调用<br>    onSubmitSignIn = () =&gt; &#123;<br>        console.log(this.state);<br>        this.props.onRouteChange(&quot;rankpage&quot;)<br>    &#125;<br>3 onChange=&#123;this.onEmailChange&#125;<br> onClick = &#123;this.onSubmitSignIn&#125;<br></code></pre></td></tr></table></figure>

<p>Q:  onSubmitSignIn doesn’t work.</p>
<h4 id="传送数据到服务器"><a href="#传送数据到服务器" class="headerlink" title="传送数据到服务器"></a>传送数据到服务器</h4><p>由前端向服务器发送请求</p>
<p>signin.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">// 箭头函数：render的时候不调用这个函数，只有当onClick的时候才调用<br>    onSubmitSignIn = () =&gt; &#123;<br>        fetch(&quot;http://localhost:3000/signin&quot;,<br>        &#123;<br>            method:&quot;post&quot;,<br>            headers:&#123;&quot;Content-Type&quot;:&quot;application/json&quot;&#125;,<br>            body:JSON.stringify(&#123;<br>                email: this.state.signInEmail,<br>                password: this.state.signInPassword<br>            &#125;)<br><br>        &#125;)<br>        console.log(this.state);<br>        this.props.onRouteChange(&quot;rankpage&quot;)<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>Fetch 失败，返回404 not found</p>
<p>检查网络： 发现我明明写的方法是post，为啥变成了get</p>
<p>我用post测后端signin接口是正常的呀。</p>
<p>![image-20201205002832834](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201205002832834.png)</p>
<h4 id="允许跨域访问"><a href="#允许跨域访问" class="headerlink" title="允许跨域访问"></a>允许跨域访问</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>by supporting CORS requests, superawesome.com can allow bob.com to access the data.</p>
<p>Read about it more at <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">MDN’s great resource here</a>!</p>
<h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>Tips: 先 ctrl c 断开 nodemon 连接</p>
<p>npm install cors</p>
<p>const cors = require(“cors”);</p>
<p>app.use(cors());</p>
<h4 id="常见失败的解决方案"><a href="#常见失败的解决方案" class="headerlink" title="常见失败的解决方案"></a>常见失败的解决方案</h4><p>在后端加入 打印error的代码，就能查看到失败的原因。</p>
<p>如果是 type error：fail to fetch</p>
<p>就可能是响应头没有允许同源， 即发送请求的地址 和 响应请求的地址 不一样时，fetch 就会失败。</p>
<p>问题原因：The issue could be with the response you are receiving from back-end. If it was working fine on the server then the problem could be with the response headers. Check the <em>Access-Control-Allow-Origin</em> (ACAO) in the response headers. Usually react’s fetch API will throw fail to fetch even after receiving response when the response headers’ ACAO and the origin of request won’t match. </p>
<p>解决方案：  If the API is using <code>express</code> for node you can use the simple <code>cors</code> package. If you want to make your site properly secure, consider using a whitelist for the <code>Access-Control-Allow-Origin</code> header.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">// express 版本<br><br>//设置跨域访问<br>app.all(&#x27;*&#x27;, function(req, res, next) &#123;<br>    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);<br>    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;);<br>    res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);<br>    res.header(&quot;X-Powered-By&quot;,&#x27; 3.2.1&#x27;)<br>    res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);<br>    next();<br>&#125;);<br><br></code></pre></td></tr></table></figure>







<ul>
<li>忘记 npm install clarifai</li>
</ul>
<ul>
<li><p>App.js:140 SyntaxError: Unexpected token &lt; in JSON at position 0</p>
<p>说明返回的是html 页面。可以用postman 试一下，可以看到通常是因为某变量没有被声明。</p>
</li>
<li><p>DevTools failed to load SourceMap: Could not load content for chrome-extension://xxxxxxxxx/writer/js/angular-ui-router.js.map: HTTP error: status code 404, net::ERR_UNKNOWN_URL_SCHEME</p>
<p>Chrome 上的拓展程序加载错误。</p>
<p>右上角三点 - 更多工具 - 拓展程序。</p>
<p>找到 id 是 xxxxx 的程序，比如我出错的是grammar for ginger 程序。</p>
<p>原来我每次访问后端 localhost:3000 的时候都跑到这来了！！ 怪不得页面啥反应也没有，控制台返回 DevTools failed to load SourceMap， 真是哭笑不得。。。</p>
<p>那就先把它卸载了吧。</p>
<p>![image-20201216190243433](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201216190243433.png)</p>
</li>
</ul>
<p>![image-20201216190432723](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201216190432723.png)</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>![image-20201205005239165](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201205005239165.png)</p>
<p>brew update</p>
<p>brew install postgresql</p>
<p>安装成功之后，安装路径为：</p>
<p>/usr/local/var/postgres</p>
<p>可以 pull 最新版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">brew postgresql-upgrade-database<br></code></pre></td></tr></table></figure>



<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>brew services start postgresql</p>
<p>![image-20201205005554035](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201205005554035.png)</p>
<p>createdb “smartbrain”</p>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>下载可视化图形操作界面 Psequel。</p>
<p>用 Psequel 连接数据库。</p>
<p>如果在连接本地的时候出问题，按以下步骤操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text"># 1 找到它的地址<br>sudo find / -name &quot;postgresql.conf&quot;<br>/usr/local/var/postgres/postgresql.conf<br># 2<br>vim postgresql.conf<br>把<br>listen_addresses = &#x27;localhost&#x27;<br>替换成<br>listen_addresses = &#x27;*&#x27;<br># 3<br>重启服务器<br>brew services restart postgresql<br># 查看<br>netstat -nlt<br>“Local Address” for port 5432 变成了 0.0.0.0.<br></code></pre></td></tr></table></figure>



<p>创建表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">CREATE TABLE users(<br>    id serial PRIMARY KEY,<br>    name VARCHAR(100),<br>    email text UNIQUE NOT NULL,<br>    entries BIGINT DEFAULT 0,<br>    joined TIMESTAMP NOT NULL<br>);<br><br>CREATE TABLE login(<br>    id serial PRIMARY KEY,<br>    hash VARCHAR(100),<br>    email text UNIQUE NOT NULL<br>    );<br></code></pre></td></tr></table></figure>



<p>这有详细的 postpresql 语法教程 <a href="https://www.postgresqltutorial.com/">https://www.postgresqltutorial.com/</a></p>
<h4 id="knex"><a href="#knex" class="headerlink" title="knex"></a>knex</h4><p>Js 操作数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Knex.js (pronounced /kəˈnɛks/) is a &quot;batteries included&quot; SQL query builder for Postgres, MSSQL, MySQL, MariaDB, SQLite3, Oracle, and Amazon Redshift designed to be flexible, portable, and fun to use. It features both traditional node style callbacks as well as a promise interface for cleaner async flow control, a stream interface, full featured query and schema builders, transaction support (with savepoints), connection pooling and standardized responses between different query clients and dialects.<br></code></pre></td></tr></table></figure>



<p>Npm install knex</p>
<p>npm install pg</p>
<p>具体语法在官网里有。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>这样全世界都能访问啦</p>
<h4 id="工具选择"><a href="#工具选择" class="headerlink" title="工具选择"></a>工具选择</h4><p>可以有以下选择，在此使用heroku。</p>
<p>![image-20201205152950920](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201205152950920.png)</p>
<p>heroku 部分如果有啥不懂的，直接看官方文档 <a href="https://devcenter.heroku.com/articles/git">https://devcenter.heroku.com/articles/git</a></p>
<p><a href="https://devcenter.heroku.com/articles/heroku-cli">https://devcenter.heroku.com/articles/heroku-cli</a></p>
<p>【心得: heroku 官网写的还不错的， 能看一手的资料，就不要看 二三手经过加工的资料💾。】</p>
<h3 id="部署后端"><a href="#部署后端" class="headerlink" title="部署后端"></a>部署后端</h3><h4 id="heroku-创建app"><a href="#heroku-创建app" class="headerlink" title="heroku 创建app"></a>heroku 创建app</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs term">brew tap heroku/brew &amp;&amp; brew install heroku<br></code></pre></td></tr></table></figure>

<p>Heroku login -i</p>
<p>到我的后端文件夹（smart-brain-api) </p>
<p>Heroku create</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Creating app... done, ⬢ damp-eyrie-02199<br>https://damp-eyrie-02199.herokuapp.com/ | https://git.heroku.com/damp-eyrie-02199.git<br></code></pre></td></tr></table></figure>

<p>![image-20201205164210960](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201205164210960.png)</p>
<p>Tips:</p>
<p>建议新建好就改成自己想要的名字。</p>
<p>不然的话，建立好的连接又要删掉重新建立。也不是不行，就是怕好不容易搞起来的连接，万一又出什么幺蛾子连不上了。</p>
<p>改名方法1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1.打开终端，登录heroku，切换到要修该的app下<br>2.执行heroku apps:rename xxx (xxx是你的app的新名称）<br>3.更新remote，<br>执行git remote rm heroku<br>执行heroku git:remote -a xxx<br></code></pre></td></tr></table></figure>

<p>改名方法2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1.打开heroku的网址，并登录<br>2.找到你要修改的app的名字，点击进入<br>3.点击setting<br>4.修改名字（只支持小写字母、数字和破折号）<br>5.更新remote<br>（1）打开终端iterm<br>（2）输入heroku login, 输入email和password进行登录<br>（3）执行git remote rm heroku<br>git remote -v<br>git remote add heroku https://git.heroku.com/XXXXX.git（XXXXX请换成修改后的heroku名字）<br>git push heroku 你的最新分支:master<br></code></pre></td></tr></table></figure>







<p>Heroku open -a app名字，如damp-eyrie-02199</p>
<p>![image-20201205172459961](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201205172459961.png)</p>
<p>成功打开～</p>
<h4 id="与-GitHub-建立连接"><a href="#与-GitHub-建立连接" class="headerlink" title="与 GitHub 建立连接"></a>与 GitHub 建立连接</h4><p>在github 新建一个仓库 smart-brain</p>
<p>还是在我的后端文件夹（smart-brain-api) </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">git init<br>git add .<br>git commit -m &quot;smart&quot;<br><br>git remote add origin https://github.com/wenjialu/smart-brain.git<br>git push --set-upstream origin master<br></code></pre></td></tr></table></figure>

<p>GitHub 联系上heroku？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">heroku git:remote -a 刚刚创的app名字，如damp-eyrie-02199<br></code></pre></td></tr></table></figure>

<h5 id="连接成功～"><a href="#连接成功～" class="headerlink" title="连接成功～"></a>连接成功～</h5><p>git remote -v 查看下，如果heroku 和 github 的仓库都对了就是成功啦～</p>
<p>![image-20201205174240762](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201205174240762.png)</p>
<p>我之前用过heroku了，现在要重命名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs term">heroku git:remote -a infinite-hamlet-23870<br>git remote rename heroku heroku-staging<br></code></pre></td></tr></table></figure>



<h4 id="上传到heroku"><a href="#上传到heroku" class="headerlink" title="上传到heroku"></a>上传到heroku</h4><p>上传到heroku 啦，见下：</p>
<h5 id="Deploying-code"><a href="#Deploying-code" class="headerlink" title="Deploying code"></a><a href="https://devcenter.heroku.com/articles/git#deploying-code">Deploying code</a></h5><p>To deploy your app to Heroku, you typically use the <code>git push</code> command to push the code from your local repository’s <a href="https://devcenter.heroku.com/articles/git-branches">master or main branch</a> to your <code>heroku</code> remote, like so:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs term"># mastet 或者 main 要根据实际情况<br>$ git push heroku master<br>Initializing repository, done.<br>updating &#x27;refs/heads/master&#x27;<br>...<br></code></pre></td></tr></table></figure>



<h4 id="查看成功了没"><a href="#查看成功了没" class="headerlink" title="查看成功了没"></a>查看成功了没</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs term">heroku open<br></code></pre></td></tr></table></figure>

<p>检查出错原因</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">heroku logs --tail<br></code></pre></td></tr></table></figure>

<p>通过日志我发现 heroku会为我的app设置动态端口（Heroku dynamically assigns your app a port），我要把写死的3000 端口改掉。</p>
<p>Heroku adds the port to the env, so you can pull it from there. Switch my listen to this:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">.listen(process.env.PORT || <span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure>

<p>在后端文件夹路径下，终端输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">PORT=5000 node server.js<br></code></pre></td></tr></table></figure>

<p>可以看到返回5000 啦</p>
<p>修改完了别忘记上传到git 和 heroku</p>
<p>![image-20201205182211270](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201205182211270.png)</p>
<p>哈哈哈哈～ 成功了哦～</p>
<h3 id="部署前端"><a href="#部署前端" class="headerlink" title="部署前端"></a>部署前端</h3><p>用同样的方法部署前端。</p>
<p>![image-20201205192330279](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201205192330279.png)</p>
<p><strong>修复bug</strong></p>
<p>提示1: node 和npm version 需要指定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">node --version<br>v12.13.1<br>npm -v<br></code></pre></td></tr></table></figure>

<p>在 package.json里面添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&quot;engines&quot;: &#123;<br>    &quot;node&quot;: &quot;12.13.1&quot;,<br>    &quot;npm&quot;: &quot;6.14.8&quot;<br>  &#125;,<br></code></pre></td></tr></table></figure>



<p>提示2: 依赖中缺少模块</p>
<p>Tachyon 模块缺少。</p>
<p>打开它给出的官方网址，找到了解决方案</p>
<p><a href="https://devcenter.heroku.com/articles/troubleshooting-node-deploys">https://devcenter.heroku.com/articles/troubleshooting-node-deploys</a></p>
<p><a href="https://help.heroku.com/n/13/general-platform-features/builds">https://help.heroku.com/n/13/general-platform-features/builds</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 重要！！<br>In order create a smaller slug size for apps, the buildpack will prune out the devDependencies from the package.json at the end of the build, so that the slug will only include the dependencies that are listed at runtime. If there is a dependency that is in the devDependencies that is needed after the prune occurs, <br><br>move the dependency to dependencies, so it is not removed.<br>or <br>heroku config:set NPM_CONFIG_PRODUCTION=false<br></code></pre></td></tr></table></figure>



<p>不知道为啥 Tachyon 模块不见了。</p>
<p>⚠️ 我打开本地 package.json 好多模块竟然都显示没有安装，非常奇怪。</p>
<p>只能全部重新安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm install tachyon <br><br>npm shrinkwrap<br>产生了一个新的lockfile, 然后再提交。 (亲测了两个项目都不用lock反而成功了，所以把这个 lockfile 删光光，重新提交git，就成功啦)<br></code></pre></td></tr></table></figure>



<p>装好后在dependencies 里面可以看到它又出现啦。</p>
<p>![image-20201206001834886](/Users/lujiawen/Library/Application Support/typora-user-images/image-20201206001834886.png)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm install package-lock.json<br><br>heroku buildpacks:set heroku/nodejs<br><br>npm shrinkwrap<br></code></pre></td></tr></table></figure>



<p>​    </p>
<p>修复 npm 和 yarn 的冲突。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">git rm yarn.lock<br>git commit -m &quot;Remove yarn lock file&quot;<br>git push --set-upstream origin master<br></code></pre></td></tr></table></figure>

<p>如果 git 分支出了问题，见我 git 篇更新部分 <a href="https://zhuanlan.zhihu.com/p/290333697">https://zhuanlan.zhihu.com/p/290333697</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 注意！ 根据项目的实际情况选择 main，master<br>git push heroku main<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">remote:  ! We have detected that you have triggered a build from source code with version ed530c8d0de5c0f450d117595c65a054dfc9cbe8<br>remote:  ! at least twice. One common cause of this behavior is attempting to deploy code from a different branch.<br>remote:  !<br>remote:  ! If you are developing on a branch and deploying via git you must run:<br>remote:  !<br>remote:  !     git push heroku &lt;branchname&gt;:main<br>remote:  !<br>remote:  ! This article goes into details on the behavior:<br>remote:  !   https://devcenter.heroku.com/articles/duplicate-build-version<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">git push heroku main:main<br></code></pre></td></tr></table></figure>





<h3 id="部署数据库"><a href="#部署数据库" class="headerlink" title="部署数据库"></a>部署数据库</h3>]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
</search>
